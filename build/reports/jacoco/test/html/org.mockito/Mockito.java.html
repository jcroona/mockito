<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="sv"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Mockito.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mockito</a> &gt; <a href="index.source.html" class="el_package">org.mockito</a> &gt; <span class="el_source">Mockito.java</span></div><h1>Mockito.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2007 Mockito contributors
 * This program is made available under the terms of the MIT License.
 */
package org.mockito;

import org.mockito.exceptions.misusing.PotentialStubbingProblem;
import org.mockito.exceptions.misusing.UnnecessaryStubbingException;
import org.mockito.internal.InternalMockHandler;
import org.mockito.internal.MockitoCore;
import org.mockito.internal.creation.MockSettingsImpl;
import org.mockito.internal.debugging.MockitoDebuggerImpl;
import org.mockito.internal.framework.DefaultMockitoFramework;
import org.mockito.internal.session.DefaultMockitoSessionBuilder;
import org.mockito.internal.verification.VerificationModeFactory;
import org.mockito.invocation.Invocation;
import org.mockito.invocation.InvocationFactory;
import org.mockito.invocation.MockHandler;
import org.mockito.junit.MockitoJUnit;
import org.mockito.junit.MockitoJUnitRunner;
import org.mockito.junit.MockitoRule;
import org.mockito.listeners.VerificationStartedEvent;
import org.mockito.listeners.VerificationStartedListener;
import org.mockito.mock.SerializableMode;
import org.mockito.plugins.MockMaker;
import org.mockito.plugins.MockitoPlugins;
import org.mockito.quality.MockitoHint;
import org.mockito.quality.Strictness;
import org.mockito.session.MockitoSessionBuilder;
import org.mockito.session.MockitoSessionLogger;
import org.mockito.stubbing.Answer;
import org.mockito.stubbing.Answer1;
import org.mockito.stubbing.LenientStubber;
import org.mockito.stubbing.OngoingStubbing;
import org.mockito.stubbing.Stubber;
import org.mockito.stubbing.Stubbing;
import org.mockito.stubbing.VoidAnswer1;
import org.mockito.verification.After;
import org.mockito.verification.Timeout;
import org.mockito.verification.VerificationAfterDelay;
import org.mockito.verification.VerificationMode;
import org.mockito.verification.VerificationWithTimeout;

/**
 * &lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;logo.png&quot; srcset=&quot;logo@2x.png 2x&quot; alt=&quot;Mockito logo&quot;/&gt;&lt;/p&gt;
 * The Mockito library enables mock creation, verification and stubbing.
 *
 * &lt;p&gt;
 * This javadoc content is also available on the &lt;a href=&quot;http://mockito.org&quot;&gt;http://mockito.org&lt;/a&gt; web page.
 * All documentation is kept in javadocs because it guarantees consistency between what's on the web and what's in the source code.
 * It allows access to documentation straight from the IDE even if you work offline.
 * It motivates Mockito developers to keep documentation up-to-date with the code that they write,
 * every day, with every commit.
 *
 * &lt;h1&gt;Contents&lt;/h1&gt;
 *
 * &lt;b&gt;
 *      &lt;a href=&quot;#0&quot;&gt;0. Migrating to Mockito 2&lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#0.1&quot;&gt;0.1 Mockito Android support&lt;/a&gt;&lt;/br/&gt;
 *      &lt;a href=&quot;#0.2&quot;&gt;0.2 Configuration-free inline mock making&lt;/a&gt;&lt;/br/&gt;
 *      &lt;a href=&quot;#1&quot;&gt;1. Let's verify some behaviour! &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#2&quot;&gt;2. How about some stubbing? &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#3&quot;&gt;3. Argument matchers &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#4&quot;&gt;4. Verifying exact number of invocations / at least once / never &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#5&quot;&gt;5. Stubbing void methods with exceptions &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#6&quot;&gt;6. Verification in order &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#7&quot;&gt;7. Making sure interaction(s) never happened on mock &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#8&quot;&gt;8. Finding redundant invocations &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#9&quot;&gt;9. Shorthand for mocks creation - &lt;code&gt;&amp;#064;Mock&lt;/code&gt; annotation &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#10&quot;&gt;10. Stubbing consecutive calls (iterator-style stubbing) &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#11&quot;&gt;11. Stubbing with callbacks &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#12&quot;&gt;12. &lt;code&gt;doReturn()&lt;/code&gt;|&lt;code&gt;doThrow()&lt;/code&gt;|&lt;code&gt;doAnswer()&lt;/code&gt;|&lt;code&gt;doNothing()&lt;/code&gt;|&lt;code&gt;doCallRealMethod()&lt;/code&gt; family of methods&lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#13&quot;&gt;13. Spying on real objects &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#14&quot;&gt;14. Changing default return values of unstubbed invocations (Since 1.7) &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#15&quot;&gt;15. Capturing arguments for further assertions (Since 1.8.0) &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#16&quot;&gt;16. Real partial mocks (Since 1.8.0) &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#17&quot;&gt;17. Resetting mocks (Since 1.8.0) &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#18&quot;&gt;18. Troubleshooting &amp; validating framework usage (Since 1.8.0) &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#19&quot;&gt;19. Aliases for behavior driven development (Since 1.8.0) &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#20&quot;&gt;20. Serializable mocks (Since 1.8.1) &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#21&quot;&gt;21. New annotations: &lt;code&gt;&amp;#064;Captor&lt;/code&gt;, &lt;code&gt;&amp;#064;Spy&lt;/code&gt;, &lt;code&gt;&amp;#064;InjectMocks&lt;/code&gt; (Since 1.8.3) &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#22&quot;&gt;22. Verification with timeout (Since 1.8.5) &lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#23&quot;&gt;23. Automatic instantiation of &lt;code&gt;&amp;#064;Spies&lt;/code&gt;, &lt;code&gt;&amp;#064;InjectMocks&lt;/code&gt; and constructor injection goodness (Since 1.9.0)&lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#24&quot;&gt;24. One-liner stubs (Since 1.9.0)&lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#25&quot;&gt;25. Verification ignoring stubs (Since 1.9.0)&lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#26&quot;&gt;26. Mocking details (Improved in 2.2.x)&lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#27&quot;&gt;27. Delegate calls to real instance (Since 1.9.5)&lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#28&quot;&gt;28. &lt;code&gt;MockMaker&lt;/code&gt; API (Since 1.9.5)&lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#29&quot;&gt;29. BDD style verification (Since 1.10.0)&lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#30&quot;&gt;30. Spying or mocking abstract classes (Since 1.10.12, further enhanced in 2.7.13 and 2.7.14)&lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#31&quot;&gt;31. Mockito mocks can be &lt;em&gt;serialized&lt;/em&gt; / &lt;em&gt;deserialized&lt;/em&gt; across classloaders (Since 1.10.0)&lt;/a&gt;&lt;/h3&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#32&quot;&gt;32. Better generic support with deep stubs (Since 1.10.0)&lt;/a&gt;&lt;/h3&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#33&quot;&gt;33. Mockito JUnit rule (Since 1.10.17)&lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#34&quot;&gt;34. Switch &lt;em&gt;on&lt;/em&gt; or &lt;em&gt;off&lt;/em&gt; plugins (Since 1.10.15)&lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#35&quot;&gt;35. Custom verification failure message (Since 2.1.0)&lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#36&quot;&gt;36. Java 8 Lambda Matcher Support (Since 2.1.0)&lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#37&quot;&gt;37. Java 8 Custom Answer Support (Since 2.1.0)&lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#38&quot;&gt;38. Meta data and generic type retention (Since 2.1.0)&lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#39&quot;&gt;39. Mocking final types, enums and final methods (Since 2.1.0)&lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#40&quot;&gt;40. Improved productivity and cleaner tests with &quot;stricter&quot; Mockito (Since 2.+)&lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#41&quot;&gt;41. Advanced public API for framework integrations (Since 2.10.+)&lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#42&quot;&gt;42. New API for integrations: listening on verification start events (Since 2.11.+)&lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#43&quot;&gt;43. New API for integrations: &lt;code&gt;MockitoSession&lt;/code&gt; is usable by testing frameworks (Since 2.15.+)&lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#44&quot;&gt;44. Deprecated &lt;code&gt;org.mockito.plugins.InstantiatorProvider&lt;/code&gt; as it was leaking internal API. it was replaced by &lt;code&gt;org.mockito.plugins.InstantiatorProvider2 (Since 2.15.4)&lt;/code&gt;&lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#45&quot;&gt;45. New JUnit Jupiter (JUnit5+) extension&lt;/a&gt;&lt;br/&gt;
 *      &lt;a href=&quot;#46&quot;&gt;46. New &lt;code&gt;Mockito.lenient()&lt;/code&gt; and &lt;code&gt;MockSettings.lenient()&lt;/code&gt; methods (Since 2.20.0&lt;/a&gt;&lt;br/&gt;
 * &lt;/b&gt;
 *
 * &lt;h3 id=&quot;0&quot;&gt;0. &lt;a class=&quot;meaningful_link&quot; href=&quot;#mockito2&quot; name=&quot;mockito2&quot;&gt;Migrating to Mockito 2&lt;/a&gt;&lt;/h3&gt;
 *
 * In order to continue improving Mockito and further improve the unit testing experience, we want you to upgrade to 2.1.0!
 * Mockito follows &lt;a href=&quot;http://semver.org/&quot;&gt;semantic versioning&lt;/a&gt; and contains breaking changes only on major version upgrades.
 * In the lifecycle of a library, breaking changes are necessary
 * to roll out a set of brand new features that alter the existing behavior or even change the API.
 * For a comprehensive guide on the new release including incompatible changes,
 * see '&lt;a href=&quot;https://github.com/mockito/mockito/wiki/What%27s-new-in-Mockito-2&quot;&gt;What's new in Mockito 2&lt;/a&gt;' wiki page.
 * We hope that you enjoy Mockito 2!
 *
 * &lt;h3 id=&quot;0.1&quot;&gt;0.1. &lt;a class=&quot;meaningful_link&quot; href=&quot;#mockito-android&quot; name=&quot;mockito-android&quot;&gt;Mockito Android support&lt;/a&gt;&lt;/h3&gt;
 *
 * With Mockito version 2.6.1 we ship &quot;native&quot; Android support. To enable Android support, add the `mockito-android` library as dependency
 * to your project. This artifact is published to the same Mockito organization and can be imported for Android as follows:
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code&gt;
 * repositories {
 *   jcenter()
 * }
 * dependencies {
 *   testCompile &quot;org.mockito:mockito-core:+&quot;
 *   androidTestCompile &quot;org.mockito:mockito-android:+&quot;
 * }
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * You can continue to run the same unit tests on a regular VM by using the `mockito-core` artifact in your &quot;testCompile&quot; scope as shown
 * above. Be aware that you cannot use the &lt;a href=&quot;#39&quot;&gt;inline mock maker&lt;/a&gt; on Android due to limitations in the Android VM.
 *
 * If you encounter issues with mocking on Android, please open an issue
 * &lt;a href=&quot;https://github.com/mockito/mockito/issues/new&quot;&gt;on the official issue tracker&lt;/a&gt;.
 * Do provide the version of Android you are working on and dependencies of your project.
 *
 * &lt;h3 id=&quot;0.2&quot;&gt;0.2. &lt;a class=&quot;meaningful_link&quot; href=&quot;#mockito-inline&quot; name=&quot;mockito-inline&quot;&gt;Configuration-free inline mock making&lt;/a&gt;&lt;/h3&gt;
 *
 * Starting with version 2.7.6, we offer the 'mockito-inline' artifact that enables &lt;a href=&quot;#39&quot;&gt;inline mock making&lt;/a&gt; without configuring
 * the MockMaker extension file. To use this, add the `mockito-inline` instead of the `mockito-core` artifact as follows:
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code&gt;
 * repositories {
 *   jcenter()
 * }
 * dependencies {
 *   testCompile &quot;org.mockito:mockito-inline:+&quot;
 * }
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * Be aware that this artifact may be abolished when the inline mock making feature is integrated into the default mock maker.
 *
 * &lt;p&gt;
 * For more information about inline mock making, see &lt;a href=&quot;#39&quot;&gt;section 39&lt;/a&gt;.
 *
 * &lt;h3 id=&quot;1&quot;&gt;1. &lt;a class=&quot;meaningful_link&quot; href=&quot;#verification&quot; name=&quot;verification&quot;&gt;Let's verify some behaviour!&lt;/a&gt;&lt;/h3&gt;
 *
 * The following examples mock a List, because most people are familiar with the interface (such as the
 * &lt;code&gt;add()&lt;/code&gt;, &lt;code&gt;get()&lt;/code&gt;, &lt;code&gt;clear()&lt;/code&gt; methods). &lt;br&gt;
 * In reality, please don't mock the List class. Use a real instance instead.
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * //Let's import Mockito statically so that the code looks clearer
 * import static org.mockito.Mockito.*;
 *
 * //mock creation
 * List mockedList = mock(List.class);
 *
 * //using mock object
 * mockedList.add(&quot;one&quot;);
 * mockedList.clear();
 *
 * //verification
 * verify(mockedList).add(&quot;one&quot;);
 * verify(mockedList).clear();
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;p&gt;
 * Once created, a mock will remember all interactions. Then you can selectively
 * verify whatever interactions you are interested in.
 * &lt;/p&gt;
 *
 *
 *
 * &lt;h3 id=&quot;2&quot;&gt;2. &lt;a class=&quot;meaningful_link&quot; href=&quot;#stubbing&quot; name=&quot;stubbing&quot;&gt;How about some stubbing?&lt;/a&gt;&lt;/h3&gt;
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * //You can mock concrete classes, not just interfaces
 * LinkedList mockedList = mock(LinkedList.class);
 *
 * //stubbing
 * when(mockedList.get(0)).thenReturn(&quot;first&quot;);
 * when(mockedList.get(1)).thenThrow(new RuntimeException());
 *
 * //following prints &quot;first&quot;
 * System.out.println(mockedList.get(0));
 *
 * //following throws runtime exception
 * System.out.println(mockedList.get(1));
 *
 * //following prints &quot;null&quot; because get(999) was not stubbed
 * System.out.println(mockedList.get(999));
 *
 * //Although it is possible to verify a stubbed invocation, usually &lt;b&gt;it's just redundant&lt;/b&gt;
 * //If your code cares what get(0) returns, then something else breaks (often even before verify() gets executed).
 * //If your code doesn't care what get(0) returns, then it should not be stubbed. Not convinced? See &lt;a href=&quot;http://monkeyisland.pl/2008/04/26/asking-and-telling&quot;&gt;here&lt;/a&gt;.
 * verify(mockedList).get(0);
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;ul&gt;
 * &lt;li&gt; By default, for all methods that return a value, a mock will return either null,
 * a primitive/primitive wrapper value, or an empty collection, as appropriate.
 * For example 0 for an int/Integer and false for a boolean/Boolean. &lt;/li&gt;
 *
 * &lt;li&gt; Stubbing can be overridden: for example common stubbing can go to
 * fixture setup but the test methods can override it.
 * Please note that overridding stubbing is a potential code smell that points out too much stubbing&lt;/li&gt;
 *
 * &lt;li&gt; Once stubbed, the method will always return a stubbed value, regardless
 * of how many times it is called. &lt;/li&gt;
 *
 * &lt;li&gt; Last stubbing is more important - when you stubbed the same method with
 * the same arguments many times.
 * Other words: &lt;b&gt;the order of stubbing matters&lt;/b&gt; but it is only meaningful rarely,
 * e.g. when stubbing exactly the same method calls or sometimes when argument matchers are used, etc.&lt;/li&gt;
 *
 * &lt;/ul&gt;
 *
 *
 *
 * &lt;h3 id=&quot;3&quot;&gt;3. &lt;a class=&quot;meaningful_link&quot; href=&quot;#argument_matchers&quot; name=&quot;argument_matchers&quot;&gt;Argument matchers&lt;/a&gt;&lt;/h3&gt;
 *
 * Mockito verifies argument values in natural java style: by using an &lt;code&gt;equals()&lt;/code&gt; method.
 * Sometimes, when extra flexibility is required then you might use argument matchers:
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * //stubbing using built-in anyInt() argument matcher
 * when(mockedList.get(anyInt())).thenReturn(&quot;element&quot;);
 *
 * //stubbing using custom matcher (let's say isValid() returns your own matcher implementation):
 * when(mockedList.contains(argThat(isValid()))).thenReturn(&quot;element&quot;);
 *
 * //following prints &quot;element&quot;
 * System.out.println(mockedList.get(999));
 *
 * //&lt;b&gt;you can also verify using an argument matcher&lt;/b&gt;
 * verify(mockedList).get(anyInt());
 *
 * //&lt;b&gt;argument matchers can also be written as Java 8 Lambdas&lt;/b&gt;
 * verify(mockedList).add(argThat(someString -&gt; someString.length() &gt; 5));
 *
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;p&gt;
 * Argument matchers allow flexible verification or stubbing.
 * {@link ArgumentMatchers Click here} {@link org.mockito.hamcrest.MockitoHamcrest or here} to see more built-in matchers
 * and examples of &lt;b&gt;custom argument matchers / hamcrest matchers&lt;/b&gt;.
 * &lt;p&gt;
 * For information solely on &lt;b&gt;custom argument matchers&lt;/b&gt; check out javadoc for {@link ArgumentMatcher} class.
 * &lt;p&gt;
 * Be reasonable with using complicated argument matching.
 * The natural matching style using &lt;code&gt;equals()&lt;/code&gt; with occasional &lt;code&gt;anyX()&lt;/code&gt; matchers tend to give clean &amp; simple tests.
 * Sometimes it's just better to refactor the code to allow &lt;code&gt;equals()&lt;/code&gt; matching or even implement &lt;code&gt;equals()&lt;/code&gt; method to help out with testing.
 * &lt;p&gt;
 * Also, read &lt;a href=&quot;#15&quot;&gt;section 15&lt;/a&gt; or javadoc for {@link ArgumentCaptor} class.
 * {@link ArgumentCaptor} is a special implementation of an argument matcher that captures argument values for further assertions.
 * &lt;p&gt;
 * &lt;b&gt;Warning on argument matchers:&lt;/b&gt;
 * &lt;p&gt;
 * If you are using argument matchers, &lt;b&gt;all arguments&lt;/b&gt; have to be provided
 * by matchers.
 * &lt;p&gt;
 The following example shows verification but the same applies to stubbing:
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 *   verify(mock).someMethod(anyInt(), anyString(), &lt;b&gt;eq(&quot;third argument&quot;)&lt;/b&gt;);
 *   //above is correct - eq() is also an argument matcher
 *
 *   verify(mock).someMethod(anyInt(), anyString(), &lt;b&gt;&quot;third argument&quot;&lt;/b&gt;);
 *   //above is incorrect - exception will be thrown because third argument is given without an argument matcher.
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;p&gt;
 * Matcher methods like &lt;code&gt;anyObject()&lt;/code&gt;, &lt;code&gt;eq()&lt;/code&gt; &lt;b&gt;do not&lt;/b&gt; return matchers.
 * Internally, they record a matcher on a stack and return a dummy value (usually null).
 * This implementation is due to static type safety imposed by the java compiler.
 * The consequence is that you cannot use &lt;code&gt;anyObject()&lt;/code&gt;, &lt;code&gt;eq()&lt;/code&gt; methods outside of verified/stubbed method.
 *
 *
 *
 *
 * &lt;h3 id=&quot;4&quot;&gt;4. &lt;a class=&quot;meaningful_link&quot; href=&quot;#exact_verification&quot; name=&quot;exact_verification&quot;&gt;Verifying exact number of invocations&lt;/a&gt; /
 * &lt;a class=&quot;meaningful_link&quot; href=&quot;#at_least_verification&quot; name=&quot;at_least_verification&quot;&gt;at least x&lt;/a&gt; / never&lt;/h3&gt;
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * //using mock
 * mockedList.add(&quot;once&quot;);
 *
 * mockedList.add(&quot;twice&quot;);
 * mockedList.add(&quot;twice&quot;);
 *
 * mockedList.add(&quot;three times&quot;);
 * mockedList.add(&quot;three times&quot;);
 * mockedList.add(&quot;three times&quot;);
 *
 * //following two verifications work exactly the same - times(1) is used by default
 * verify(mockedList).add(&quot;once&quot;);
 * verify(mockedList, times(1)).add(&quot;once&quot;);
 *
 * //exact number of invocations verification
 * verify(mockedList, times(2)).add(&quot;twice&quot;);
 * verify(mockedList, times(3)).add(&quot;three times&quot;);
 *
 * //verification using never(). never() is an alias to times(0)
 * verify(mockedList, never()).add(&quot;never happened&quot;);
 *
 * //verification using atLeast()/atMost()
 * verify(mockedList, atLeastOnce()).add(&quot;three times&quot;);
 * verify(mockedList, atLeast(2)).add(&quot;three times&quot;);
 * verify(mockedList, atMost(5)).add(&quot;three times&quot;);
 *
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;p&gt;
 * &lt;b&gt;times(1) is the default.&lt;/b&gt; Therefore using times(1) explicitly can be
 * omitted.
 *
 *
 *
 *
 * &lt;h3 id=&quot;5&quot;&gt;5. &lt;a class=&quot;meaningful_link&quot; href=&quot;#stubbing_with_exceptions&quot; name=&quot;stubbing_with_exceptions&quot;&gt;Stubbing void methods with exceptions&lt;/a&gt;&lt;/h3&gt;
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 *   doThrow(new RuntimeException()).when(mockedList).clear();
 *
 *   //following throws RuntimeException:
 *   mockedList.clear();
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * Read more about &lt;code&gt;doThrow()&lt;/code&gt;|&lt;code&gt;doAnswer()&lt;/code&gt; family of methods in &lt;a href=&quot;#12&quot;&gt;section 12&lt;/a&gt;.
 * &lt;p&gt;
 *
 * &lt;h3 id=&quot;6&quot;&gt;6. &lt;a class=&quot;meaningful_link&quot; href=&quot;#in_order_verification&quot; name=&quot;in_order_verification&quot;&gt;Verification in order&lt;/a&gt;&lt;/h3&gt;
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * // A. Single mock whose methods must be invoked in a particular order
 * List singleMock = mock(List.class);
 *
 * //using a single mock
 * singleMock.add(&quot;was added first&quot;);
 * singleMock.add(&quot;was added second&quot;);
 *
 * //create an inOrder verifier for a single mock
 * InOrder inOrder = inOrder(singleMock);
 *
 * //following will make sure that add is first called with &quot;was added first&quot;, then with &quot;was added second&quot;
 * inOrder.verify(singleMock).add(&quot;was added first&quot;);
 * inOrder.verify(singleMock).add(&quot;was added second&quot;);
 *
 * // B. Multiple mocks that must be used in a particular order
 * List firstMock = mock(List.class);
 * List secondMock = mock(List.class);
 *
 * //using mocks
 * firstMock.add(&quot;was called first&quot;);
 * secondMock.add(&quot;was called second&quot;);
 *
 * //create inOrder object passing any mocks that need to be verified in order
 * InOrder inOrder = inOrder(firstMock, secondMock);
 *
 * //following will make sure that firstMock was called before secondMock
 * inOrder.verify(firstMock).add(&quot;was called first&quot;);
 * inOrder.verify(secondMock).add(&quot;was called second&quot;);
 *
 * // Oh, and A + B can be mixed together at will
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * Verification in order is flexible - &lt;b&gt;you don't have to verify all
 * interactions&lt;/b&gt; one-by-one but only those that you are interested in
 * testing in order.
 * &lt;p&gt;
 * Also, you can create an InOrder object passing only the mocks that are relevant for
 * in-order verification.
 *
 *
 *
 *
 * &lt;h3 id=&quot;7&quot;&gt;7. &lt;a class=&quot;meaningful_link&quot; href=&quot;#never_verification&quot; name=&quot;never_verification&quot;&gt;Making sure interaction(s) never happened on mock&lt;/a&gt;&lt;/h3&gt;
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * //using mocks - only mockOne is interacted
 * mockOne.add(&quot;one&quot;);
 *
 * //ordinary verification
 * verify(mockOne).add(&quot;one&quot;);
 *
 * //verify that method was never called on a mock
 * verify(mockOne, never()).add(&quot;two&quot;);
 *
 * //verify that other mocks were not interacted
 * verifyZeroInteractions(mockTwo, mockThree);
 *
 * &lt;/code&gt;&lt;/pre&gt;
 *
 *
 *
 *
 * &lt;h3 id=&quot;8&quot;&gt;8. &lt;a class=&quot;meaningful_link&quot; href=&quot;#finding_redundant_invocations&quot; name=&quot;finding_redundant_invocations&quot;&gt;Finding redundant invocations&lt;/a&gt;&lt;/h3&gt;
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * //using mocks
 * mockedList.add(&quot;one&quot;);
 * mockedList.add(&quot;two&quot;);
 *
 * verify(mockedList).add(&quot;one&quot;);
 *
 * //following verification will fail
 * verifyNoMoreInteractions(mockedList);
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * A word of &lt;b&gt;warning&lt;/b&gt;:
 * Some users who did a lot of classic, expect-run-verify mocking tend to use &lt;code&gt;verifyNoMoreInteractions()&lt;/code&gt; very often, even in every test method.
 * &lt;code&gt;verifyNoMoreInteractions()&lt;/code&gt; is not recommended to use in every test method.
 * &lt;code&gt;verifyNoMoreInteractions()&lt;/code&gt; is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.
 * Abusing it leads to &lt;strong&gt;overspecified&lt;/strong&gt;, &lt;strong&gt;less maintainable&lt;/strong&gt; tests. You can find further reading
 * &lt;a href=&quot;http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/&quot;&gt;here&lt;/a&gt;.
 *
 * &lt;p&gt;
 * See also {@link Mockito#never()} - it is more explicit and
 * communicates the intent well.
 * &lt;p&gt;
 *
 *
 *
 *
 * &lt;h3 id=&quot;9&quot;&gt;9. &lt;a class=&quot;meaningful_link&quot; href=&quot;#mock_annotation&quot; name=&quot;mock_annotation&quot;&gt;Shorthand for mocks creation - &lt;code&gt;&amp;#064;Mock&lt;/code&gt; annotation&lt;/a&gt;&lt;/h3&gt;
 *
 * &lt;ul&gt;
 * &lt;li&gt;Minimizes repetitive mock creation code.&lt;/li&gt;
 * &lt;li&gt;Makes the test class more readable.&lt;/li&gt;
 * &lt;li&gt;Makes the verification error easier to read because the &lt;b&gt;field name&lt;/b&gt;
 * is used to identify the mock.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 *   public class ArticleManagerTest {
 *
 *       &amp;#064;Mock private ArticleCalculator calculator;
 *       &amp;#064;Mock private ArticleDatabase database;
 *       &amp;#064;Mock private UserProvider userProvider;
 *
 *       private ArticleManager manager;
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;b&gt;Important!&lt;/b&gt; This needs to be somewhere in the base class or a test
 * runner:
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * MockitoAnnotations.initMocks(testClass);
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * You can use built-in runner: {@link MockitoJUnitRunner} or a rule: {@link MockitoRule}.
 * For JUnit5 tests, refer to the JUnit5 extension described in &lt;a href=&quot;#45&quot;&gt;section 45&lt;/a&gt;.
 * &lt;p&gt;
 * Read more here: {@link MockitoAnnotations}
 *
 *
 *
 *
 * &lt;h3 id=&quot;10&quot;&gt;10. &lt;a class=&quot;meaningful_link&quot; href=&quot;#stubbing_consecutive_calls&quot; name=&quot;stubbing_consecutive_calls&quot;&gt;Stubbing consecutive calls&lt;/a&gt; (iterator-style stubbing)&lt;/h3&gt;
 *
 * Sometimes we need to stub with different return value/exception for the same
 * method call. Typical use case could be mocking iterators.
 * Original version of Mockito did not have this feature to promote simple mocking.
 * For example, instead of iterators one could use {@link Iterable} or simply
 * collections. Those offer natural ways of stubbing (e.g. using real
 * collections). In rare scenarios stubbing consecutive calls could be useful,
 * though:
 * &lt;p&gt;
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * when(mock.someMethod(&quot;some arg&quot;))
 *   .thenThrow(new RuntimeException())
 *   .thenReturn(&quot;foo&quot;);
 *
 * //First call: throws runtime exception:
 * mock.someMethod(&quot;some arg&quot;);
 *
 * //Second call: prints &quot;foo&quot;
 * System.out.println(mock.someMethod(&quot;some arg&quot;));
 *
 * //Any consecutive call: prints &quot;foo&quot; as well (last stubbing wins).
 * System.out.println(mock.someMethod(&quot;some arg&quot;));
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * Alternative, shorter version of consecutive stubbing:
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * when(mock.someMethod(&quot;some arg&quot;))
 *   .thenReturn(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;strong&gt;Warning&lt;/strong&gt; : if instead of chaining {@code .thenReturn()} calls, multiple stubbing with the same matchers or arguments
 * is used, then each stubbing will override the previous one:
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * //All mock.someMethod(&quot;some arg&quot;) calls will return &quot;two&quot;
 * when(mock.someMethod(&quot;some arg&quot;))
 *   .thenReturn(&quot;one&quot;)
 * when(mock.someMethod(&quot;some arg&quot;))
 *   .thenReturn(&quot;two&quot;)
 * &lt;/code&gt;&lt;/pre&gt;
 *
 *
 *
 * &lt;h3 id=&quot;11&quot;&gt;11. &lt;a class=&quot;meaningful_link&quot; href=&quot;#answer_stubs&quot; name=&quot;answer_stubs&quot;&gt;Stubbing with callbacks&lt;/a&gt;&lt;/h3&gt;
 *
 * Allows stubbing with generic {@link Answer} interface.
 * &lt;p&gt;
 * Yet another controversial feature which was not included in Mockito
 * originally. We recommend simply stubbing with &lt;code&gt;thenReturn()&lt;/code&gt; or
 * &lt;code&gt;thenThrow()&lt;/code&gt;, which should be enough to test/test-drive
 * any clean &amp; simple code. However, if you do have a need to stub with the generic Answer interface, here is an example:
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * when(mock.someMethod(anyString())).thenAnswer(
 *     new Answer() {
 *         public Object answer(InvocationOnMock invocation) {
 *             Object[] args = invocation.getArguments();
 *             Object mock = invocation.getMock();
 *             return &quot;called with arguments: &quot; + Arrays.toString(args);
 *         }
 * });
 *
 * //Following prints &quot;called with arguments: [foo]&quot;
 * System.out.println(mock.someMethod(&quot;foo&quot;));
 * &lt;/code&gt;&lt;/pre&gt;
 *
 *
 *
 *
 * &lt;h3 id=&quot;12&quot;&gt;12. &lt;a class=&quot;meaningful_link&quot; href=&quot;#do_family_methods_stubs&quot; name=&quot;do_family_methods_stubs&quot;&gt;&lt;code&gt;doReturn()&lt;/code&gt;|&lt;code&gt;doThrow()&lt;/code&gt;|
 * &lt;code&gt;doAnswer()&lt;/code&gt;|&lt;code&gt;doNothing()&lt;/code&gt;|&lt;code&gt;doCallRealMethod()&lt;/code&gt; family of methods&lt;/a&gt;&lt;/h3&gt;
 *
 * Stubbing void methods requires a different approach from {@link Mockito#when(Object)} because the compiler does not
 * like void methods inside brackets...
 * &lt;p&gt;
 * Use &lt;code&gt;doThrow()&lt;/code&gt; when you want to stub a void method with an exception:
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 *   doThrow(new RuntimeException()).when(mockedList).clear();
 *
 *   //following throws RuntimeException:
 *   mockedList.clear();
 * &lt;/code&gt;&lt;/pre&gt;
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * You can use &lt;code&gt;doThrow()&lt;/code&gt;, &lt;code&gt;doAnswer()&lt;/code&gt;, &lt;code&gt;doNothing()&lt;/code&gt;, &lt;code&gt;doReturn()&lt;/code&gt;
 * and &lt;code&gt;doCallRealMethod()&lt;/code&gt; in place of the corresponding call with &lt;code&gt;when()&lt;/code&gt;, for any method.
 * It is necessary when you
 * &lt;ul&gt;
 *     &lt;li&gt;stub void methods&lt;/li&gt;
 *     &lt;li&gt;stub methods on spy objects (see below)&lt;/li&gt;
 *     &lt;li&gt;stub the same method more than once, to change the behaviour of a mock in the middle of a test.&lt;/li&gt;
 * &lt;/ul&gt;
 * but you may prefer to use these methods in place of the alternative with &lt;code&gt;when()&lt;/code&gt;, for all of your stubbing calls.
 * &lt;p&gt;
 * Read more about these methods:
 * &lt;p&gt;
 * {@link Mockito#doReturn(Object)}
 * &lt;p&gt;
 * {@link Mockito#doThrow(Throwable...)}
 * &lt;p&gt;
 * {@link Mockito#doThrow(Class)}
 * &lt;p&gt;
 * {@link Mockito#doAnswer(Answer)}
 * &lt;p&gt;
 * {@link Mockito#doNothing()}
 * &lt;p&gt;
 * {@link Mockito#doCallRealMethod()}
 *
 *
 *
 *
 * &lt;h3 id=&quot;13&quot;&gt;13. &lt;a class=&quot;meaningful_link&quot; href=&quot;#spy&quot; name=&quot;spy&quot;&gt;Spying on real objects&lt;/a&gt;&lt;/h3&gt;
 *
 * You can create spies of real objects. When you use the spy then the &lt;b&gt;real&lt;/b&gt; methods are called
 * (unless a method was stubbed).
 * &lt;p&gt;
 * Real spies should be used &lt;b&gt;carefully and occasionally&lt;/b&gt;, for example when dealing with legacy code.
 *
 * &lt;p&gt;
 * Spying on real objects can be associated with &quot;partial mocking&quot; concept.
 * &lt;b&gt;Before the release 1.8&lt;/b&gt;, Mockito spies were not real partial mocks.
 * The reason was we thought partial mock is a code smell.
 * At some point we found legitimate use cases for partial mocks
 * (3rd party interfaces, interim refactoring of legacy code, the full article is
 * &lt;a href=&quot;http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring&quot;&gt;here&lt;/a&gt;)
 * &lt;p&gt;
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 *   List list = new LinkedList();
 *   List spy = spy(list);
 *
 *   //optionally, you can stub out some methods:
 *   when(spy.size()).thenReturn(100);
 *
 *   //using the spy calls &lt;b&gt;*real*&lt;/b&gt; methods
 *   spy.add(&quot;one&quot;);
 *   spy.add(&quot;two&quot;);
 *
 *   //prints &quot;one&quot; - the first element of a list
 *   System.out.println(spy.get(0));
 *
 *   //size() method was stubbed - 100 is printed
 *   System.out.println(spy.size());
 *
 *   //optionally, you can verify
 *   verify(spy).add(&quot;one&quot;);
 *   verify(spy).add(&quot;two&quot;);
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;h4&gt;Important gotcha on spying real objects!&lt;/h4&gt;
 * &lt;ol&gt;
 * &lt;li&gt;Sometimes it's impossible or impractical to use {@link Mockito#when(Object)} for stubbing spies.
 * Therefore when using spies please consider &lt;code&gt;doReturn&lt;/code&gt;|&lt;code&gt;Answer&lt;/code&gt;|&lt;code&gt;Throw()&lt;/code&gt; family of
 * methods for stubbing. Example:
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 *   List list = new LinkedList();
 *   List spy = spy(list);
 *
 *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)
 *   when(spy.get(0)).thenReturn(&quot;foo&quot;);
 *
 *   //You have to use doReturn() for stubbing
 *   doReturn(&quot;foo&quot;).when(spy).get(0);
 * &lt;/code&gt;&lt;/pre&gt;
 * &lt;/li&gt;
 *
 * &lt;li&gt;Mockito &lt;b&gt;*does not*&lt;/b&gt; delegate calls to the passed real instance, instead it actually creates a copy of it.
 * So if you keep the real instance and interact with it, don't expect the spied to be aware of those interaction
 * and their effect on real instance state.
 * The corollary is that when an &lt;b&gt;*unstubbed*&lt;/b&gt; method is called &lt;b&gt;*on the spy*&lt;/b&gt; but &lt;b&gt;*not on the real instance*&lt;/b&gt;,
 * you won't see any effects on the real instance.
 * &lt;/li&gt;
 *
 * &lt;li&gt;Watch out for final methods.
 * Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.
 * Also you won't be able to verify those method as well.
 * &lt;/li&gt;
 * &lt;/ol&gt;
 *
 *
 *
 *
 * &lt;h3 id=&quot;14&quot;&gt;14. Changing &lt;a class=&quot;meaningful_link&quot; href=&quot;#defaultreturn&quot; name=&quot;defaultreturn&quot;&gt;default return values of unstubbed invocations&lt;/a&gt; (Since 1.7)&lt;/h3&gt;
 *
 * You can create a mock with specified strategy for its return values.
 * It's quite an advanced feature and typically you don't need it to write decent tests.
 * However, it can be helpful for working with &lt;b&gt;legacy systems&lt;/b&gt;.
 * &lt;p&gt;
 * It is the default answer so it will be used &lt;b&gt;only when you don't&lt;/b&gt; stub the method call.
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 *   Foo mock = mock(Foo.class, Mockito.RETURNS_SMART_NULLS);
 *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer());
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;p&gt;
 * Read more about this interesting implementation of &lt;i&gt;Answer&lt;/i&gt;: {@link Mockito#RETURNS_SMART_NULLS}
 *
 *
 *
 *
 * &lt;h3 id=&quot;15&quot;&gt;15. &lt;a class=&quot;meaningful_link&quot; href=&quot;#captors&quot; name=&quot;captors&quot;&gt;Capturing arguments&lt;/a&gt; for further assertions (Since 1.8.0)&lt;/h3&gt;
 *
 * Mockito verifies argument values in natural java style: by using an &lt;code&gt;equals()&lt;/code&gt; method.
 * This is also the recommended way of matching arguments because it makes tests clean &amp; simple.
 * In some situations though, it is helpful to assert on certain arguments after the actual verification.
 * For example:
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 *   ArgumentCaptor&amp;lt;Person&amp;gt; argument = ArgumentCaptor.forClass(Person.class);
 *   verify(mock).doSomething(argument.capture());
 *   assertEquals(&quot;John&quot;, argument.getValue().getName());
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;b&gt;Warning:&lt;/b&gt; it is recommended to use ArgumentCaptor with verification &lt;b&gt;but not&lt;/b&gt; with stubbing.
 * Using ArgumentCaptor with stubbing may decrease test readability because captor is created outside of assert (aka verify or 'then') block.
 * Also it may reduce defect localization because if stubbed method was not called then no argument is captured.
 * &lt;p&gt;
 * In a way ArgumentCaptor is related to custom argument matchers (see javadoc for {@link ArgumentMatcher} class).
 * Both techniques can be used for making sure certain arguments where passed to mocks.
 * However, ArgumentCaptor may be a better fit if:
 * &lt;ul&gt;
 * &lt;li&gt;custom argument matcher is not likely to be reused&lt;/li&gt;
 * &lt;li&gt;you just need it to assert on argument values to complete verification&lt;/li&gt;
 * &lt;/ul&gt;
 * Custom argument matchers via {@link ArgumentMatcher} are usually better for stubbing.
 *
 *
 *
 *
 * &lt;h3 id=&quot;16&quot;&gt;16. &lt;a class=&quot;meaningful_link&quot; href=&quot;#partial_mocks&quot; name=&quot;partial_mocks&quot;&gt;Real partial mocks&lt;/a&gt; (Since 1.8.0)&lt;/h3&gt;
 *
 *  Finally, after many internal debates &amp; discussions on the mailing list, partial mock support was added to Mockito.
 *  Previously we considered partial mocks as code smells. However, we found a legitimate use case for partial mocks - more reading:
 *  &lt;a href=&quot;http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring&quot;&gt;here&lt;/a&gt;
 *  &lt;p&gt;
 *  &lt;b&gt;Before release 1.8&lt;/b&gt; &lt;code&gt;spy()&lt;/code&gt; was not producing real partial mocks and it was confusing for some users.
 *  Read more about spying: &lt;a href=&quot;#13&quot;&gt;here&lt;/a&gt; or in javadoc for {@link Mockito#spy(Object)} method.
 *  &lt;p&gt;
 *  &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 *    //you can create partial mock with spy() method:
 *    List list = spy(new LinkedList());
 *
 *    //you can enable partial mock capabilities selectively on mocks:
 *    Foo mock = mock(Foo.class);
 *    //Be sure the real implementation is 'safe'.
 *    //If real implementation throws exceptions or depends on specific state of the object then you're in trouble.
 *    when(mock.someMethod()).thenCallRealMethod();
 *  &lt;/code&gt;&lt;/pre&gt;
 *
 * As usual you are going to read &lt;b&gt;the partial mock warning&lt;/b&gt;:
 * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.
 * How does partial mock fit into this paradigm? Well, it just doesn't...
 * Partial mock usually means that the complexity has been moved to a different method on the same object.
 * In most cases, this is not the way you want to design your application.
 * &lt;p&gt;
 * However, there are rare cases when partial mocks come handy:
 * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
 * However, I wouldn't use partial mocks for new, test-driven &amp; well-designed code.
 *
 *
 *
 *
 * &lt;h3 id=&quot;17&quot;&gt;17. &lt;a class=&quot;meaningful_link&quot; href=&quot;#resetting_mocks&quot; name=&quot;resetting_mocks&quot;&gt;Resetting mocks&lt;/a&gt; (Since 1.8.0)&lt;/h3&gt;
 *
 * Smart Mockito users hardly use this feature because they know it could be a sign of poor tests.
 * Normally, you don't need to reset your mocks, just create new mocks for each test method.
 * &lt;p&gt;
 * Instead of &lt;code&gt;reset()&lt;/code&gt; please consider writing simple, small and focused test methods over lengthy, over-specified tests.
 * &lt;b&gt;First potential code smell is &lt;code&gt;reset()&lt;/code&gt; in the middle of the test method.&lt;/b&gt; This probably means you're testing too much.
 * Follow the whisper of your test methods: &quot;Please keep us small &amp; focused on single behavior&quot;.
 * There are several threads about it on mockito mailing list.
 * &lt;p&gt;
 * The only reason we added &lt;code&gt;reset()&lt;/code&gt; method is to
 * make it possible to work with container-injected mocks.
 * For more information see FAQ (&lt;a href=&quot;https://github.com/mockito/mockito/wiki/FAQ&quot;&gt;here&lt;/a&gt;).
 * &lt;p&gt;
 * &lt;b&gt;Don't harm yourself.&lt;/b&gt; &lt;code&gt;reset()&lt;/code&gt; in the middle of the test method is a code smell (you're probably testing too much).
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 *   List mock = mock(List.class);
 *   when(mock.size()).thenReturn(10);
 *   mock.add(1);
 *
 *   reset(mock);
 *   //at this point the mock forgot any interactions &amp; stubbing
 * &lt;/code&gt;&lt;/pre&gt;
 *
 *
 *
 *
 * &lt;h3 id=&quot;18&quot;&gt;18. &lt;a class=&quot;meaningful_link&quot; href=&quot;#framework_validation&quot; name=&quot;framework_validation&quot;&gt;Troubleshooting &amp; validating framework usage&lt;/a&gt; (Since 1.8.0)&lt;/h3&gt;
 *
 * First of all, in case of any trouble, I encourage you to read the Mockito FAQ:
 * &lt;a href=&quot;https://github.com/mockito/mockito/wiki/FAQ&quot;&gt;https://github.com/mockito/mockito/wiki/FAQ&lt;/a&gt;
 * &lt;p&gt;
 * In case of questions you may also post to mockito mailing list:
 * &lt;a href=&quot;http://groups.google.com/group/mockito&quot;&gt;http://groups.google.com/group/mockito&lt;/a&gt;
 * &lt;p&gt;
 * Next, you should know that Mockito validates if you use it correctly &lt;b&gt;all the time&lt;/b&gt;.
 * However, there's a gotcha so please read the javadoc for {@link Mockito#validateMockitoUsage()}
 *
 *
 *
 *
 * &lt;h3 id=&quot;19&quot;&gt;19. &lt;a class=&quot;meaningful_link&quot; href=&quot;#bdd_mockito&quot; name=&quot;bdd_mockito&quot;&gt;Aliases for behavior driven development&lt;/a&gt; (Since 1.8.0)&lt;/h3&gt;
 *
 * Behavior Driven Development style of writing tests uses &lt;b&gt;//given //when //then&lt;/b&gt; comments as fundamental parts of your test methods.
 * This is exactly how we write our tests and we warmly encourage you to do so!
 * &lt;p&gt;
 * Start learning about BDD here: &lt;a href=&quot;http://en.wikipedia.org/wiki/Behavior_Driven_Development&quot;&gt;http://en.wikipedia.org/wiki/Behavior_Driven_Development&lt;/a&gt;
 * &lt;p&gt;
 * The problem is that current stubbing api with canonical role of &lt;b&gt;when&lt;/b&gt; word does not integrate nicely with &lt;b&gt;//given //when //then&lt;/b&gt; comments.
 * It's because stubbing belongs to &lt;b&gt;given&lt;/b&gt; component of the test and not to the &lt;b&gt;when&lt;/b&gt; component of the test.
 * Hence {@link BDDMockito} class introduces an alias so that you stub method calls with {@link BDDMockito#given(Object)} method.
 * Now it really nicely integrates with the &lt;b&gt;given&lt;/b&gt; component of a BDD style test!
 * &lt;p&gt;
 * Here is how the test might look like:
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * import static org.mockito.BDDMockito.*;
 *
 * Seller seller = mock(Seller.class);
 * Shop shop = new Shop(seller);
 *
 * public void shouldBuyBread() throws Exception {
 *   //given
 *   given(seller.askForBread()).willReturn(new Bread());
 *
 *   //when
 *   Goods goods = shop.buyBread();
 *
 *   //then
 *   assertThat(goods, containBread());
 * }
 * &lt;/code&gt;&lt;/pre&gt;
 *
 *
 *
 *
 * &lt;h3 id=&quot;20&quot;&gt;20. &lt;a class=&quot;meaningful_link&quot; href=&quot;#serializable_mocks&quot; name=&quot;serializable_mocks&quot;&gt;Serializable mocks&lt;/a&gt; (Since 1.8.1)&lt;/h3&gt;
 *
 * Mocks can be made serializable. With this feature you can use a mock in a place that requires dependencies to be serializable.
 * &lt;p&gt;
 * WARNING: This should be rarely used in unit testing.
 * &lt;p&gt;
 * The behaviour was implemented for a specific use case of a BDD spec that had an unreliable external dependency.  This
 * was in a web environment and the objects from the external dependency were being serialized to pass between layers.
 * &lt;p&gt;
 * To create serializable mock use {@link MockSettings#serializable()}:
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 *   List serializableMock = mock(List.class, withSettings().serializable());
 * &lt;/code&gt;&lt;/pre&gt;
 * &lt;p&gt;
 * The mock can be serialized assuming all the normal &lt;a href='http://java.sun.com/j2se/1.5.0/docs/api/java/io/Serializable.html'&gt;
 * serialization requirements&lt;/a&gt; are met by the class.
 * &lt;p&gt;
 * Making a real object spy serializable is a bit more effort as the spy(...) method does not have an overloaded version
 * which accepts MockSettings. No worries, you will hardly ever use it.
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * List&amp;lt;Object&amp;gt; list = new ArrayList&amp;lt;Object&amp;gt;();
 * List&amp;lt;Object&amp;gt; spy = mock(ArrayList.class, withSettings()
 *                 .spiedInstance(list)
 *                 .defaultAnswer(CALLS_REAL_METHODS)
 *                 .serializable());
 * &lt;/code&gt;&lt;/pre&gt;
 *
 *
 *
 *
 * &lt;h3 id=&quot;21&quot;&gt;21. New annotations: &lt;a class=&quot;meaningful_link&quot; href=&quot;#captor_annotation&quot; name=&quot;captor_annotation&quot;&gt;&lt;code&gt;&amp;#064;Captor&lt;/code&gt;&lt;/a&gt;,
 * &lt;a class=&quot;meaningful_link&quot; href=&quot;#spy_annotation&quot; name=&quot;spy_annotation&quot;&gt;&lt;code&gt;&amp;#064;Spy&lt;/code&gt;&lt;/a&gt;,
 * &lt;a class=&quot;meaningful_link&quot; href=&quot;#injectmocks_annotation&quot; name=&quot;injectmocks_annotation&quot;&gt;&lt;code&gt;&amp;#064;InjectMocks&lt;/code&gt;&lt;/a&gt; (Since 1.8.3)&lt;/h3&gt;
 *
 * &lt;p&gt;
 * Release 1.8.3 brings new annotations that may be helpful on occasion:
 *
 * &lt;ul&gt;
 * &lt;li&gt;&amp;#064;{@link Captor} simplifies creation of {@link ArgumentCaptor}
 * - useful when the argument to capture is a nasty generic class and you want to avoid compiler warnings
 * &lt;li&gt;&amp;#064;{@link Spy} - you can use it instead {@link Mockito#spy(Object)}.
 * &lt;li&gt;&amp;#064;{@link InjectMocks} - injects mock or spy fields into tested object automatically.
 * &lt;/ul&gt;
 *
 * &lt;p&gt;
 * Note that &amp;#064;{@link InjectMocks} can also be used in combination with the &amp;#064;{@link Spy} annotation, it means
 * that Mockito will inject mocks into the partial mock under test. This complexity is another good reason why you
 * should only use partial mocks as a last resort. See point 16 about partial mocks.
 *
 * &lt;p&gt;
 * All new annotations are &lt;b&gt;*only*&lt;/b&gt; processed on {@link MockitoAnnotations#initMocks(Object)}.
 * Just like for &amp;#064;{@link Mock} annotation you can use the built-in runner: {@link MockitoJUnitRunner} or rule:
 * {@link MockitoRule}.
 * &lt;p&gt;
 *
 *
 *
 *
 * &lt;h3 id=&quot;22&quot;&gt;22. &lt;a class=&quot;meaningful_link&quot; href=&quot;#verification_timeout&quot; name=&quot;verification_timeout&quot;&gt;Verification with timeout&lt;/a&gt; (Since 1.8.5)&lt;/h3&gt;
 * &lt;p&gt;
 * Allows verifying with timeout. It causes a verify to wait for a specified period of time for a desired
 * interaction rather than fails immediately if had not already happened. May be useful for testing in concurrent
 * conditions.
 * &lt;p&gt;
 * This feature should be used rarely - figure out a better way of testing your multi-threaded system.
 * &lt;p&gt;
 * Not yet implemented to work with InOrder verification.
 * &lt;p&gt;
 * Examples:
 * &lt;p&gt;
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 *   //passes when someMethod() is called no later than within 100 ms
 *   //exits immediately when verification is satisfied (e.g. may not wait full 100 ms)
 *   verify(mock, timeout(100)).someMethod();
 *   //above is an alias to:
 *   verify(mock, timeout(100).times(1)).someMethod();
 *
 *   //passes as soon as someMethod() has been called 2 times under 100 ms
 *   verify(mock, timeout(100).times(2)).someMethod();
 *
 *   //equivalent: this also passes as soon as someMethod() has been called 2 times under 100 ms
 *   verify(mock, timeout(100).atLeast(2)).someMethod();
 * &lt;/code&gt;&lt;/pre&gt;
 *
 *
 *
 *
 * &lt;h3 id=&quot;23&quot;&gt;23. &lt;a class=&quot;meaningful_link&quot; href=&quot;#automatic_instantiation&quot; name=&quot;automatic_instantiation&quot;&gt;Automatic instantiation of &lt;code&gt;&amp;#064;Spies&lt;/code&gt;,
 * &lt;code&gt;&amp;#064;InjectMocks&lt;/code&gt;&lt;/a&gt; and &lt;a class=&quot;meaningful_link&quot; href=&quot;#constructor_injection&quot; name=&quot;constructor_injection&quot;&gt;constructor injection goodness&lt;/a&gt; (Since 1.9.0)&lt;/h3&gt;
 *
 * &lt;p&gt;
 * Mockito will now try to instantiate &amp;#064;{@link Spy} and will instantiate &amp;#064;{@link InjectMocks} fields
 * using &lt;b&gt;constructor&lt;/b&gt; injection, &lt;b&gt;setter&lt;/b&gt; injection, or &lt;b&gt;field&lt;/b&gt; injection.
 * &lt;p&gt;
 * To take advantage of this feature you need to use {@link MockitoAnnotations#initMocks(Object)}, {@link MockitoJUnitRunner}
 * or {@link MockitoRule}.
 * &lt;p&gt;
 * Read more about available tricks and the rules of injection in the javadoc for {@link InjectMocks}
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * //instead:
 * &amp;#064;Spy BeerDrinker drinker = new BeerDrinker();
 * //you can write:
 * &amp;#064;Spy BeerDrinker drinker;
 *
 * //same applies to &amp;#064;InjectMocks annotation:
 * &amp;#064;InjectMocks LocalPub;
 * &lt;/code&gt;&lt;/pre&gt;
 *
 *
 *
 *
 * &lt;h3 id=&quot;24&quot;&gt;24. &lt;a class=&quot;meaningful_link&quot; href=&quot;#one_liner_stub&quot; name=&quot;one_liner_stub&quot;&gt;One-liner stubs&lt;/a&gt; (Since 1.9.0)&lt;/h3&gt;
 * &lt;p&gt;
 * Mockito will now allow you to create mocks when stubbing.
 * Basically, it allows to create a stub in one line of code.
 * This can be helpful to keep test code clean.
 * For example, some boring stub can be created &amp; stubbed at field initialization in a test:
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * public class CarTest {
 *   Car boringStubbedCar = when(mock(Car.class).shiftGear()).thenThrow(EngineNotStarted.class).getMock();
 *
 *   &amp;#064;Test public void should... {}
 * &lt;/code&gt;&lt;/pre&gt;
 *
 *
 *
 *
 * &lt;h3 id=&quot;25&quot;&gt;25. &lt;a class=&quot;meaningful_link&quot; href=&quot;#ignore_stubs_verification&quot; name=&quot;ignore_stubs_verification&quot;&gt;Verification ignoring stubs&lt;/a&gt; (Since 1.9.0)&lt;/h3&gt;
 * &lt;p&gt;
 * Mockito will now allow to ignore stubbing for the sake of verification.
 * Sometimes useful when coupled with &lt;code&gt;verifyNoMoreInteractions()&lt;/code&gt; or verification &lt;code&gt;inOrder()&lt;/code&gt;.
 * Helps avoiding redundant verification of stubbed calls - typically we're not interested in verifying stubs.
 * &lt;p&gt;
 * &lt;b&gt;Warning&lt;/b&gt;, &lt;code&gt;ignoreStubs()&lt;/code&gt; might lead to overuse of verifyNoMoreInteractions(ignoreStubs(...));
 * Bear in mind that Mockito does not recommend bombarding every test with &lt;code&gt;verifyNoMoreInteractions()&lt;/code&gt;
 * for the reasons outlined in javadoc for {@link Mockito#verifyNoMoreInteractions(Object...)}
 * &lt;p&gt;Some examples:
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * verify(mock).foo();
 * verify(mockTwo).bar();
 *
 * //ignores all stubbed methods:
 * verifyNoMoreInteractions(ignoreStubs(mock, mockTwo));
 *
 * //creates InOrder that will ignore stubbed
 * InOrder inOrder = inOrder(ignoreStubs(mock, mockTwo));
 * inOrder.verify(mock).foo();
 * inOrder.verify(mockTwo).bar();
 * inOrder.verifyNoMoreInteractions();
 * &lt;/code&gt;&lt;/pre&gt;
 * &lt;p&gt;
 * Advanced examples and more details can be found in javadoc for {@link Mockito#ignoreStubs(Object...)}
 *
 *
 *
 *
 * &lt;h3 id=&quot;26&quot;&gt;26. &lt;a class=&quot;meaningful_link&quot; href=&quot;#mocking_details&quot; name=&quot;mocking_details&quot;&gt;Mocking details&lt;/a&gt; (Improved in 2.2.x)&lt;/h3&gt;
 * &lt;p&gt;
 *
 * Mockito offers API to inspect the details of a mock object.
 * This API is useful for advanced users and mocking framework integrators.
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 *   //To identify whether a particular object is a mock or a spy:
 *   Mockito.mockingDetails(someObject).isMock();
 *   Mockito.mockingDetails(someObject).isSpy();
 *
 *   //Getting details like type to mock or default answer:
 *   MockingDetails details = mockingDetails(mock);
 *   details.getMockCreationSettings().getTypeToMock();
 *   details.getMockCreationSettings().getDefaultAnswer();
 *
 *   //Getting invocations and stubbings of the mock:
 *   MockingDetails details = mockingDetails(mock);
 *   details.getInvocations();
 *   details.getStubbings();
 *
 *   //Printing all interactions (including stubbing, unused stubs)
 *   System.out.println(mockingDetails(mock).printInvocations());
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * For more information see javadoc for {@link MockingDetails}.
 *
 * &lt;h3 id=&quot;27&quot;&gt;27. &lt;a class=&quot;meaningful_link&quot; href=&quot;#delegating_call_to_real_instance&quot; name=&quot;delegating_call_to_real_instance&quot;&gt;Delegate calls to real instance&lt;/a&gt; (Since 1.9.5)&lt;/h3&gt;
 *
 * &lt;p&gt;Useful for spies or partial mocks of objects &lt;strong&gt;that are difficult to mock or spy&lt;/strong&gt; using the usual spy API.
 * Since Mockito 1.10.11, the delegate may or may not be of the same type as the mock.
 * If the type is different, a matching method needs to be found on delegate type otherwise an exception is thrown.
 *
 * Possible use cases for this feature:
 * &lt;ul&gt;
 *     &lt;li&gt;Final classes but with an interface&lt;/li&gt;
 *     &lt;li&gt;Already custom proxied object&lt;/li&gt;
 *     &lt;li&gt;Special objects with a finalize method, i.e. to avoid executing it 2 times&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;The difference with the regular spy:
 * &lt;ul&gt;
 *   &lt;li&gt;
 *     The regular spy ({@link #spy(Object)}) contains &lt;strong&gt;all&lt;/strong&gt; state from the spied instance
 *     and the methods are invoked on the spy. The spied instance is only used at mock creation to copy the state from.
 *     If you call a method on a regular spy and it internally calls other methods on this spy, those calls are remembered
 *     for verifications, and they can be effectively stubbed.
 *   &lt;/li&gt;
 *   &lt;li&gt;
 *     The mock that delegates simply delegates all methods to the delegate.
 *     The delegate is used all the time as methods are delegated onto it.
 *     If you call a method on a mock that delegates and it internally calls other methods on this mock,
 *     those calls are &lt;strong&gt;not&lt;/strong&gt; remembered for verifications, stubbing does not have effect on them, too.
 *     Mock that delegates is less powerful than the regular spy but it is useful when the regular spy cannot be created.
 *   &lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;
 * See more information in docs for {@link AdditionalAnswers#delegatesTo(Object)}.
 *
 *
 *
 *
 * &lt;h3 id=&quot;28&quot;&gt;28. &lt;a class=&quot;meaningful_link&quot; href=&quot;#mock_maker_plugin&quot; name=&quot;mock_maker_plugin&quot;&gt;&lt;code&gt;MockMaker&lt;/code&gt; API&lt;/a&gt; (Since 1.9.5)&lt;/h3&gt;
 * &lt;p&gt;Driven by requirements and patches from Google Android guys Mockito now offers an extension point
 *   that allows replacing the proxy generation engine. By default, Mockito uses &lt;a href=&quot;https://github.com/raphw/byte-buddy&quot;&gt;Byte Buddy&lt;/a&gt;
 *   to create dynamic proxies.
 * &lt;p&gt;The extension point is for advanced users that want to extend Mockito. For example, it is now possible
 *   to use Mockito for Android testing with a help of &lt;a href=&quot;https://github.com/crittercism/dexmaker&quot;&gt;dexmaker&lt;/a&gt;.
 * &lt;p&gt;For more details, motivations and examples please refer to
 * the docs for {@link org.mockito.plugins.MockMaker}.
 *
 *
 *
 *
 * &lt;h3 id=&quot;29&quot;&gt;29. &lt;a class=&quot;meaningful_link&quot; href=&quot;#BDD_behavior_verification&quot; name=&quot;BDD_behavior_verification&quot;&gt;BDD style verification&lt;/a&gt; (Since 1.10.0)&lt;/h3&gt;
 *
 * Enables Behavior Driven Development (BDD) style verification by starting verification with the BDD &lt;b&gt;then&lt;/b&gt; keyword.
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * given(dog.bark()).willReturn(2);
 *
 * // when
 * ...
 *
 * then(person).should(times(2)).ride(bike);
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * For more information and an example see {@link BDDMockito#then(Object)}
 *
 *
 *
 *
 * &lt;h3 id=&quot;30&quot;&gt;30. &lt;a class=&quot;meaningful_link&quot; href=&quot;#spying_abstract_classes&quot; name=&quot;spying_abstract_classes&quot;&gt;Spying or mocking abstract classes (Since 1.10.12, further enhanced in 2.7.13 and 2.7.14)&lt;/a&gt;&lt;/h3&gt;
 *
 * It is now possible to conveniently spy on abstract classes. Note that overusing spies hints at code design smells (see {@link #spy(Object)}).
 * &lt;p&gt;
 * Previously, spying was only possible on instances of objects.
 * New API makes it possible to use constructor when creating an instance of the mock.
 * This is particularly useful for mocking abstract classes because the user is no longer required to provide an instance of the abstract class.
 * At the moment, only parameter-less constructor is supported, let us know if it is not enough.
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * //convenience API, new overloaded spy() method:
 * SomeAbstract spy = spy(SomeAbstract.class);
 *
 * //Mocking abstract methods, spying default methods of an interface (only available since 2.7.13)
 * Function&lt;Foo, Bar&gt; function = spy(Function.class);
 *
 * //Robust API, via settings builder:
 * OtherAbstract spy = mock(OtherAbstract.class, withSettings()
 *    .useConstructor().defaultAnswer(CALLS_REAL_METHODS));
 *
 * //Mocking an abstract class with constructor arguments (only available since 2.7.14)
 * SomeAbstract spy = mock(SomeAbstract.class, withSettings()
 *   .useConstructor(&quot;arg1&quot;, 123).defaultAnswer(CALLS_REAL_METHODS));
 *
 * //Mocking a non-static inner abstract class:
 * InnerAbstract spy = mock(InnerAbstract.class, withSettings()
 *    .useConstructor().outerInstance(outerInstance).defaultAnswer(CALLS_REAL_METHODS));
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * For more information please see {@link MockSettings#useConstructor(Object...)}.
 *
 *
 *
 *
 * &lt;h3 id=&quot;31&quot;&gt;31. &lt;a class=&quot;meaningful_link&quot; href=&quot;#serilization_across_classloader&quot; name=&quot;serilization_across_classloader&quot;&gt;Mockito mocks can be &lt;em&gt;serialized&lt;/em&gt; / &lt;em&gt;deserialized&lt;/em&gt; across classloaders (Since 1.10.0)&lt;/a&gt;&lt;/h3&gt;
 *
 * Mockito introduces serialization across classloader.
 *
 * Like with any other form of serialization, all types in the mock hierarchy have to serializable, inclusing answers.
 * As this serialization mode require considerably more work, this is an opt-in setting.
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * // use regular serialization
 * mock(Book.class, withSettings().serializable());
 *
 * // use serialization across classloaders
 * mock(Book.class, withSettings().serializable(ACROSS_CLASSLOADERS));
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * For more details see {@link MockSettings#serializable(SerializableMode)}.
 *
 *
 *
 *
 * &lt;h3 id=&quot;32&quot;&gt;32. &lt;a class=&quot;meaningful_link&quot; href=&quot;#better_generic_support_with_deep_stubs&quot; name=&quot;better_generic_support_with_deep_stubs&quot;&gt;Better generic support with deep stubs (Since 1.10.0)&lt;/a&gt;&lt;/h3&gt;
 *
 * Deep stubbing has been improved to find generic information if available in the class.
 * That means that classes like this can be used without having to mock the behavior.
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * class Lines extends List&amp;lt;Line&amp;gt; {
 *     // ...
 * }
 *
 * lines = mock(Lines.class, RETURNS_DEEP_STUBS);
 *
 * // Now Mockito understand this is not an Object but a Line
 * Line line = lines.iterator().next();
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * Please note that in most scenarios a mock returning a mock is wrong.
 *
 *
 *
 *
 * &lt;h3 id=&quot;33&quot;&gt;33. &lt;a class=&quot;meaningful_link&quot; href=&quot;#mockito_junit_rule&quot; name=&quot;mockito_junit_rule&quot;&gt;Mockito JUnit rule (Since 1.10.17)&lt;/a&gt;&lt;/h3&gt;
 *
 * Mockito now offers a JUnit rule. Until now in JUnit there were two ways to initialize fields annotated by Mockito annotations
 * such as &lt;code&gt;&amp;#064;{@link Mock}&lt;/code&gt;, &lt;code&gt;&amp;#064;{@link Spy}&lt;/code&gt;, &lt;code&gt;&amp;#064;{@link InjectMocks}&lt;/code&gt;, etc.
 *
 * &lt;ul&gt;
 *     &lt;li&gt;Annotating the JUnit test class with a &lt;code&gt;&amp;#064;{@link org.junit.runner.RunWith}({@link MockitoJUnitRunner}.class)&lt;/code&gt;&lt;/li&gt;
 *     &lt;li&gt;Invoking &lt;code&gt;{@link MockitoAnnotations#initMocks(Object)}&lt;/code&gt; in the &lt;code&gt;&amp;#064;{@link org.junit.Before}&lt;/code&gt; method&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * Now you can choose to use a rule :
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * &amp;#064;RunWith(YetAnotherRunner.class)
 * public class TheTest {
 *     &amp;#064;Rule public MockitoRule mockito = MockitoJUnit.rule();
 *     // ...
 * }
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * For more information see {@link MockitoJUnit#rule()}.
 *
 *
 *
 *
 * &lt;h3 id=&quot;34&quot;&gt;34. &lt;a class=&quot;meaningful_link&quot; href=&quot;#plugin_switch&quot; name=&quot;plugin_switch&quot;&gt;Switch &lt;em&gt;on&lt;/em&gt; or &lt;em&gt;off&lt;/em&gt; plugins (Since 1.10.15)&lt;/a&gt;&lt;/h3&gt;
 *
 * An incubating feature made it's way in mockito that will allow to toggle a mockito-plugin.
 *
 * More information here {@link org.mockito.plugins.PluginSwitch}.
 *
 *
 * &lt;h3 id=&quot;35&quot;&gt;35. &lt;a class=&quot;meaningful_link&quot; href=&quot;#Custom_verification_failure_message&quot; name=&quot;Custom_verification_failure_message&quot;&gt;Custom verification failure message&lt;/a&gt; (Since 2.1.0)&lt;/h3&gt;
 * &lt;p&gt;
 * Allows specifying a custom message to be printed if verification fails.
 * &lt;p&gt;
 * Examples:
 * &lt;p&gt;
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 *
 * // will print a custom message on verification failure
 * verify(mock, description(&quot;This will print on failure&quot;)).someMethod();
 *
 * // will work with any verification mode
 * verify(mock, times(2).description(&quot;someMethod should be called twice&quot;)).someMethod();
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;h3 id=&quot;36&quot;&gt;36. &lt;a class=&quot;meaningful_link&quot; href=&quot;#Java_8_Lambda_Matching&quot; name=&quot;Java_8_Lambda_Matching&quot;&gt;Java 8 Lambda Matcher Support&lt;/a&gt; (Since 2.1.0)&lt;/h3&gt;
 * &lt;p&gt;
 * You can use Java 8 lambda expressions with {@link ArgumentMatcher} to reduce the dependency on {@link ArgumentCaptor}.
 * If you need to verify that the input to a function call on a mock was correct, then you would normally
 * use the {@link ArgumentCaptor} to find the operands used and then do subsequent assertions on them. While
 * for complex examples this can be useful, it's also long-winded.&lt;p&gt;
 * Writing a lambda to express the match is quite easy. The argument to your function, when used in conjunction
 * with argThat, will be passed to the ArgumentMatcher as a strongly typed object, so it is possible
 * to do anything with it.
 * &lt;p&gt;
 * Examples:
 * &lt;p&gt;
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 *
 * // verify a list only had strings of a certain length added to it
 * // note - this will only compile under Java 8
 * verify(list, times(2)).add(argThat(string -&gt; string.length() &lt; 5));
 *
 * // Java 7 equivalent - not as neat
 * verify(list, times(2)).add(argThat(new ArgumentMatcher&lt;String&gt;(){
 *     public boolean matches(String arg) {
 *         return arg.length() &lt; 5;
 *     }
 * }));
 *
 * // more complex Java 8 example - where you can specify complex verification behaviour functionally
 * verify(target, times(1)).receiveComplexObject(argThat(obj -&gt; obj.getSubObject().get(0).equals(&quot;expected&quot;)));
 *
 * // this can also be used when defining the behaviour of a mock under different inputs
 * // in this case if the input list was fewer than 3 items the mock returns null
 * when(mock.someMethod(argThat(list -&gt; list.size()&lt;3))).thenReturn(null);
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;h3 id=&quot;37&quot;&gt;37. &lt;a class=&quot;meaningful_link&quot; href=&quot;#Java_8_Custom_Answers&quot; name=&quot;Java_8_Custom_Answers&quot;&gt;Java 8 Custom Answer Support&lt;/a&gt; (Since 2.1.0)&lt;/h3&gt;
 * &lt;p&gt;
 * As the {@link Answer} interface has just one method it is already possible to implement it in Java 8 using
 * a lambda expression for very simple situations. The more you need to use the parameters of the method call,
 * the more you need to typecast the arguments from {@link org.mockito.invocation.InvocationOnMock}.
 *
 * &lt;p&gt;
 * Examples:
 * &lt;p&gt;
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * // answer by returning 12 every time
 * doAnswer(invocation -&gt; 12).when(mock).doSomething();
 *
 * // answer by using one of the parameters - converting into the right
 * // type as your go - in this case, returning the length of the second string parameter
 * // as the answer. This gets long-winded quickly, with casting of parameters.
 * doAnswer(invocation -&gt; ((String)invocation.getArgument(1)).length())
 *     .when(mock).doSomething(anyString(), anyString(), anyString());
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * For convenience it is possible to write custom answers/actions, which use the parameters to the method call,
 * as Java 8 lambdas. Even in Java 7 and lower these custom answers based on a typed interface can reduce boilerplate.
 * In particular, this approach will make it easier to test functions which use callbacks.
 *
 * The methods {@link AdditionalAnswers#answer(Answer1) answer} and {@link AdditionalAnswers#answerVoid(VoidAnswer1) answerVoid}
 * can be used to create the answer. They rely on the related answer interfaces in {@link org.mockito.stubbing} that
 * support answers up to 5 parameters.
 *
 * &lt;p&gt;
 * Examples:
 * &lt;p&gt;
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 *
 * // Example interface to be mocked has a function like:
 * void execute(String operand, Callback callback);
 *
 * // the example callback has a function and the class under test
 * // will depend on the callback being invoked
 * void receive(String item);
 *
 * // Java 8 - style 1
 * doAnswer(AdditionalAnswers.&lt;String,Callback&gt;answerVoid((operand, callback) -&gt; callback.receive(&quot;dummy&quot;))
 *     .when(mock).execute(anyString(), any(Callback.class));
 *
 * // Java 8 - style 2 - assuming static import of AdditionalAnswers
 * doAnswer(answerVoid((String operand, Callback callback) -&gt; callback.receive(&quot;dummy&quot;))
 *     .when(mock).execute(anyString(), any(Callback.class));
 *
 * // Java 8 - style 3 - where mocking function to is a static member of test class
 * private static void dummyCallbackImpl(String operation, Callback callback) {
 *     callback.receive(&quot;dummy&quot;);
 * }
 *
 * doAnswer(answerVoid(TestClass::dummyCallbackImpl)
 *     .when(mock).execute(anyString(), any(Callback.class));
 *
 * // Java 7
 * doAnswer(answerVoid(new VoidAnswer2&lt;String, Callback&gt;() {
 *     public void answer(String operation, Callback callback) {
 *         callback.receive(&quot;dummy&quot;);
 *     }})).when(mock).execute(anyString(), any(Callback.class));
 *
 * // returning a value is possible with the answer() function
 * // and the non-void version of the functional interfaces
 * // so if the mock interface had a method like
 * boolean isSameString(String input1, String input2);
 *
 * // this could be mocked
 * // Java 8
 * doAnswer(AdditionalAnswers.&lt;Boolean,String,String&gt;answer((input1, input2) -&gt; input1.equals(input2))))
 *     .when(mock).execute(anyString(), anyString());
 *
 * // Java 7
 * doAnswer(answer(new Answer2&lt;String, String, String&gt;() {
 *     public String answer(String input1, String input2) {
 *         return input1 + input2;
 *     }})).when(mock).execute(anyString(), anyString());
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;h3 id=&quot;38&quot;&gt;38. &lt;a class=&quot;meaningful_link&quot; href=&quot;#Meta_Data_And_Generics&quot; name=&quot;Meta_Data_And_Generics&quot;&gt;Meta data and generic type retention&lt;/a&gt; (Since 2.1.0)&lt;/h3&gt;
 *
 * &lt;p&gt;
 * Mockito now preserves annotations on mocked methods and types as well as generic meta data. Previously, a mock type did not preserve
 * annotations on types unless they were explicitly inherited and never retained annotations on methods. As a consequence, the following
 * conditions now hold true:
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * {@literal @}{@code MyAnnotation
 *  class Foo {
 *    List&lt;String&gt; bar() { ... }
 *  }
 *
 *  Class&lt;?&gt; mockType = mock(Foo.class).getClass();
 *  assert mockType.isAnnotationPresent(MyAnnotation.class);
 *  assert mockType.getDeclaredMethod(&quot;bar&quot;).getGenericReturnType() instanceof ParameterizedType;
 * }&lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;p&gt;
 * When using Java 8, Mockito now also preserves type annotations. This is default behavior and might not hold &lt;a href=&quot;#28&quot;&gt;if an
 * alternative {@link org.mockito.plugins.MockMaker} is used&lt;/a&gt;.
 *
 * &lt;h3 id=&quot;39&quot;&gt;39. &lt;a class=&quot;meaningful_link&quot; href=&quot;#Mocking_Final&quot; name=&quot;Mocking_Final&quot;&gt;Mocking final types, enums and final methods&lt;/a&gt; (Since 2.1.0)&lt;/h3&gt;
 *
 * Mockito now offers an {@link Incubating}, optional support for mocking final classes and methods.
 * This is a fantastic improvement that demonstrates Mockito's everlasting quest for improving testing experience.
 * Our ambition is that Mockito &quot;just works&quot; with final classes and methods.
 * Previously they were considered &lt;em&gt;unmockable&lt;/em&gt;, preventing the user from mocking.
 * We already started discussing how to make this feature enabled by default.
 * Currently, the feature is still optional as we wait for more feedback from the community.
 *
 * &lt;p&gt;
 * This alternative mock maker which uses
 * a combination of both Java instrumentation API and sub-classing rather than creating a new class to represent
 * a mock. This way, it becomes possible to mock final types and methods.
 *
 * &lt;p&gt;
 * This mock maker is &lt;strong&gt;turned off by default&lt;/strong&gt; because it is based on completely different mocking mechanism
 * that requires more feedback from the community. It can be activated explicitly by the mockito extension mechanism,
 * just create in the classpath a file &lt;code&gt;/mockito-extensions/org.mockito.plugins.MockMaker&lt;/code&gt;
 * containing the value &lt;code&gt;mock-maker-inline&lt;/code&gt;.
 *
 * &lt;p&gt;
 * As a convenience, the Mockito team provides an artifact where this mock maker is preconfigured. Instead of using the
 * &lt;i&gt;mockito-core&lt;/i&gt; artifact, include the &lt;i&gt;mockito-inline&lt;/i&gt; artifact in your project. Note that this artifact is
 * likely to be discontinued once mocking of final classes and methods gets integrated into the default mock maker.
 *
 * &lt;p&gt;
 * Some noteworthy notes about this mock maker:
 * &lt;ul&gt;
 *     &lt;li&gt;Mocking final types and enums is incompatible with mock settings like :
 *     &lt;ul&gt;
 *         &lt;li&gt;explicitly serialization support &lt;code&gt;withSettings().serializable()&lt;/code&gt;&lt;/li&gt;
 *         &lt;li&gt;extra-interfaces &lt;code&gt;withSettings().extraInterfaces()&lt;/code&gt;&lt;/li&gt;
 *     &lt;/ul&gt;
 *     &lt;/li&gt;
 *     &lt;li&gt;Some methods cannot be mocked
 *         &lt;ul&gt;
 *              &lt;li&gt;Package-visible methods of &lt;code&gt;java.*&lt;/code&gt;&lt;/li&gt;
 *              &lt;li&gt;&lt;code&gt;native&lt;/code&gt; methods&lt;/li&gt;
 *         &lt;/ul&gt;
 *     &lt;/li&gt;
 *     &lt;li&gt;This mock maker has been designed around Java Agent runtime attachment ; this require a compatible JVM,
 *     that is part of the JDK (or Java 9 VM). When running on a non-JDK VM prior to Java 9, it is however possible to
 *     manually add the &lt;a href=&quot;http://bytebuddy.net&quot;&gt;Byte Buddy Java agent jar&lt;/a&gt; using the &lt;code&gt;-javaagent&lt;/code&gt;
 *     parameter upon starting the JVM.
 *     &lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;
 * If you are interested in more details of this feature please read the javadoc of
 * &lt;code&gt;org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker&lt;/code&gt;
 *
 * &lt;h3 id=&quot;40&quot;&gt;40. &lt;a class=&quot;meaningful_link&quot; href=&quot;#strict_mockito&quot; name=&quot;strict_mockito&quot;&gt;
 *     Improved productivity and cleaner tests with &quot;stricter&quot; Mockito&lt;/a&gt; (Since 2.+)&lt;/h3&gt;
 *
 * To quickly find out how &quot;stricter&quot; Mockito can make you more productive and get your tests cleaner, see:
 * &lt;ul&gt;
 *     &lt;li&gt;Strict stubbing with JUnit Rules - {@link MockitoRule#strictness(Strictness)} with {@link Strictness#STRICT_STUBS}&lt;/li&gt;
 *     &lt;li&gt;Strict stubbing with JUnit Runner - {@link MockitoJUnitRunner.StrictStubs}&lt;/li&gt;
 *     &lt;li&gt;Strict stubbing if you cannot use runner/rule (like TestNG) - {@link MockitoSession}&lt;/li&gt;
 *     &lt;li&gt;Unnecessary stubbing detection with {@link MockitoJUnitRunner}&lt;/li&gt;
 *     &lt;li&gt;Stubbing argument mismatch warnings, documented in {@link MockitoHint}&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * Mockito is a &quot;loose&quot; mocking framework by default.
 * Mocks can be interacted with without setting any expectations beforehand.
 * This is intentional and it improves the quality of tests by forcing users to be explicit about what they want to stub / verify.
 * It is also very intuitive, easy to use and blends nicely with &quot;given&quot;, &quot;when&quot;, &quot;then&quot; template of clean test code.
 * This is also different from the classic mocking frameworks of the past, they were &quot;strict&quot; by default.
 * &lt;p&gt;
 * Being &quot;loose&quot; by default makes Mockito tests harder to debug at times.
 * There are scenarios where misconfigured stubbing (like using a wrong argument) forces the user to run the test with a debugger.
 * Ideally, tests failures are immediately obvious and don't require debugger to identify the root cause.
 * Starting with version 2.1 Mockito has been getting new features that nudge the framework towards &quot;strictness&quot;.
 * We want Mockito to offer fantastic debuggability while not losing its core mocking style, optimized for
 * intuitiveness, explicitness and clean test code.
 * &lt;p&gt;
 * Help Mockito! Try the new features, give us feedback, join the discussion about Mockito strictness at GitHub
 * &lt;a href=&quot;https://github.com/mockito/mockito/issues/769&quot;&gt;issue 769&lt;/a&gt;.
 *
 * &lt;h3 id=&quot;41&quot;&gt;41. &lt;a class=&quot;meaningful_link&quot; href=&quot;#framework_integrations_api&quot; name=&quot;framework_integrations_api&quot;&gt;
 *      Advanced public API for framework integrations (Since 2.10.+)&lt;/a&gt;&lt;/h3&gt;
 *
 * In Summer 2017 we decided that Mockito
 * &lt;a href=&quot;https://www.linkedin.com/pulse/mockito-vs-powermock-opinionated-dogmatic-static-mocking-faber&quot;&gt;
 * should offer better API
 * &lt;/a&gt;
 * for advanced framework integrations.
 * The new API is not intended for users who want to write unit tests.
 * It is intended for other test tools and mocking frameworks that need to extend or wrap Mockito with some custom logic.
 * During the design and implementation process (&lt;a href=&quot;https://github.com/mockito/mockito/issues/1110&quot;&gt;issue 1110&lt;/a&gt;)
 * we have developed and changed following public API elements:
 * &lt;ul&gt;
 *     &lt;li&gt;New {@link MockitoPlugins} -
 *      Enables framework integrators to get access to default Mockito plugins.
 *      Useful when one needs to implement custom plugin such as {@link MockMaker}
 *      and delegate some behavior to the default Mockito implementation.
 *     &lt;/li&gt;
 *     &lt;li&gt;New {@link MockSettings#build(Class)} -
 *      Creates immutable view of mock settings used later by Mockito.
 *      Useful for creating invocations with {@link InvocationFactory} or when implementing custom {@link MockHandler}.
 *     &lt;/li&gt;
 *     &lt;li&gt;New {@link MockingDetails#getMockHandler()} -
 *      Other frameworks may use the mock handler to programmatically simulate invocations on mock objects.
 *     &lt;/li&gt;
 *     &lt;li&gt;New {@link MockHandler#getMockSettings()} -
 *      Useful to get hold of the setting the mock object was created with.
 *     &lt;/li&gt;
 *     &lt;li&gt;New {@link InvocationFactory} -
 *      Provides means to create instances of {@link Invocation} objects.
 *      Useful for framework integrations that need to programmatically simulate method calls on mock objects.
 *     &lt;/li&gt;
 *     &lt;li&gt;New {@link MockHandler#getInvocationContainer()} -
 *      Provides access to invocation container object which has no methods (marker interface).
 *      Container is needed to hide the internal implementation and avoid leaking it to the public API.
 *     &lt;/li&gt;
 *     &lt;li&gt;Changed {@link Stubbing} -
 *      it now extends {@link Answer} interface.
 *      It is backwards compatible because Stubbing interface is not extensible (see {@link NotExtensible}).
 *      The change should be seamless to our users.
 *     &lt;/li&gt;
 *     &lt;li&gt;Deprecated {@link InternalMockHandler} -
 *       In order to accommodate API changes we needed to deprecate this interface.
 *       The interface was always documented as internal, we don't have evidence it was used by the community.
 *       The deprecation should be completely seamless for our users.
 *     &lt;/li&gt;
 *     &lt;li&gt;{@link NotExtensible} -
 *       Public annotation that indicates to the user that she should not provide custom implementations of given type.
 *       Helps framework integrators and our users understand how to use Mockito API safely.
 *     &lt;/li&gt;
 * &lt;/ul&gt;
 * Do you have feedback? Please leave comment in &lt;a href=&quot;https://github.com/mockito/mockito/issues/1110&quot;&gt;issue 1110&lt;/a&gt;.
 *
 * &lt;h3 id=&quot;42&quot;&gt;42. &lt;a class=&quot;meaningful_link&quot; href=&quot;#verifiation_started_listener&quot; name=&quot;verifiation_started_listener&quot;&gt;
 *       New API for integrations: listening on verification start events (Since 2.11.+)&lt;/a&gt;&lt;/h3&gt;
 *
 * Framework integrations such as &lt;a href=&quot;https://projects.spring.io/spring-boot&quot;&gt;Spring Boot&lt;/a&gt; needs public API to tackle double-proxy use case
 * (&lt;a href=&quot;https://github.com/mockito/mockito/issues/1191&quot;&gt;issue 1191&lt;/a&gt;).
 * We added:
 * &lt;ul&gt;
 *     &lt;li&gt;New {@link VerificationStartedListener} and {@link VerificationStartedEvent}
 *      enable framework integrators to replace the mock object for verification.
 *      The main driving use case is &lt;a href=&quot;https://projects.spring.io/spring-boot/&quot;&gt;Spring Boot&lt;/a&gt; integration.
 *      For details see Javadoc for {@link VerificationStartedListener}.
 *     &lt;/li&gt;
 *     &lt;li&gt;New public method {@link MockSettings#verificationStartedListeners(VerificationStartedListener...)}
 *     allows to supply verification started listeners at mock creation time.
 *     &lt;/li&gt;
 *     &lt;li&gt;New handy method {@link MockingDetails#getMock()} was added to make the {@code MockingDetails} API more complete.
 *     We found this method useful during the implementation.
 *     &lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;h3 id=&quot;43&quot;&gt;43. &lt;a class=&quot;meaningful_link&quot; href=&quot;#mockito_session_testing_frameworks&quot; name=&quot;mockito_session_testing_frameworks&quot;&gt;
 *       New API for integrations: &lt;code&gt;MockitoSession&lt;/code&gt; is usable by testing frameworks (Since 2.15.+)&lt;/a&gt;&lt;/h3&gt;
 *
 * &lt;p&gt;{@link MockitoSessionBuilder} and {@link MockitoSession} were enhanced to enable reuse by testing framework
 * integrations (e.g. {@link MockitoRule} for JUnit):&lt;/p&gt;
 * &lt;ul&gt;
 *     &lt;li&gt;{@link MockitoSessionBuilder#initMocks(Object...)} allows to pass in multiple test class instances for
 *      initialization of fields annotated with Mockito annotations like {@link org.mockito.Mock}.
 *      This method is useful for advanced framework integrations (e.g. JUnit Jupiter), when a test uses multiple,
 *      e.g. nested, test class instances.
 *     &lt;/li&gt;
 *     &lt;li&gt;{@link MockitoSessionBuilder#name(String)} allows to pass a name from the testing framework to the
 *      {@link MockitoSession} that will be used for printing warnings when {@link Strictness#WARN} is used.
 *     &lt;/li&gt;
 *     &lt;li&gt;{@link MockitoSessionBuilder#logger(MockitoSessionLogger)} makes it possible to customize the logger used
 *      for hints/warnings produced when finishing mocking (useful for testing and to connect reporting capabilities
 *      provided by testing frameworks such as JUnit Jupiter).
 *     &lt;/li&gt;
 *     &lt;li&gt;{@link MockitoSession#setStrictness(Strictness)} allows to change the strictness of a {@link MockitoSession}
 *      for one-off scenarios, e.g. it enables configuring a default strictness for all tests in a class but makes it
 *      possible to change the strictness for a single or a few tests.
 *     &lt;/li&gt;
 *     &lt;li&gt;{@link MockitoSession#finishMocking(Throwable)} was added to avoid confusion that may arise because
 *      there are multiple competing failures. It will disable certain checks when the supplied &lt;em&gt;failure&lt;/em&gt;
 *      is not {@code null}.
 *     &lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;h3 id=&quot;44&quot;&gt;44. &lt;a class=&quot;meaningful_link&quot; href=&quot;#mockito_instantiator_provider_deprecation&quot; name=&quot;mockito_instantiator_provider_deprecation&quot;&gt;
 *       Deprecated &lt;code&gt;org.mockito.plugins.InstantiatorProvider&lt;/code&gt; as it was leaking internal API. it was
 *       replaced by &lt;code&gt;org.mockito.plugins.InstantiatorProvider2 (Since 2.15.4)&lt;/a&gt;&lt;/h3&gt;
 *
 * &lt;p&gt;{@link org.mockito.plugins.InstantiatorProvider} returned an internal API. Hence it was deprecated and replaced
 * by {@link org.mockito.plugins.InstantiatorProvider2}. Old {@link org.mockito.plugins.InstantiatorProvider
 * instantiator providers} will continue to work, but it is recommended to switch to the new API.&lt;/p&gt;
 *
 * &lt;h3 id=&quot;45&quot;&gt;45. &lt;a class=&quot;meaningful_link&quot; href=&quot;#junit5_mockito&quot; name=&quot;junit5_mockito&quot;&gt;New JUnit Jupiter (JUnit5+) extension&lt;/a&gt;&lt;/h3&gt;
 *
 * For integration with JUnit Jupiter (JUnit5+), use the `org.mockito:mockito-junit-jupiter` artifact.
 * For more information about the usage of the integration, see &lt;a href=&quot;http://javadoc.io/page/org.mockito/mockito-junit-jupiter/latest/org/mockito/junit/jupiter/MockitoExtension.html&quot;&gt;the JavaDoc of &lt;code&gt;MockitoExtension&lt;/code&gt;&lt;/a&gt;.
 *
 * &lt;h3 id=&quot;46&quot;&gt;46. &lt;a class=&quot;meaningful_link&quot; href=&quot;#mockito_lenient&quot; name=&quot;mockito_lenient&quot;&gt;
 *       New &lt;code&gt;Mockito.lenient()&lt;/code&gt; and &lt;code&gt;MockSettings.lenient()&lt;/code&gt; methods (Since 2.20.0)&lt;/a&gt;&lt;/h3&gt;
 *
 * Strict stubbing feature is available since early Mockito 2.
 * It is very useful because it drives cleaner tests and improved productivity.
 * Strict stubbing reports unnecessary stubs, detects stubbing argument mismatch and makes the tests more DRY ({@link Strictness#STRICT_STUBS}).
 * This comes with a trade-off: in some cases, you may get false negatives from strict stubbing.
 * To remedy those scenarios you can now configure specific stubbing to be lenient, while all the other stubbings and mocks use strict stubbing:
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 *   lenient().when(mock.foo()).thenReturn(&quot;ok&quot;);
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * If you want all the stubbings on a given mock to be lenient, you can configure the mock accordingly:
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 *   Foo mock = Mockito.mock(Foo.class, withSettings().lenient());
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * For more information refer to {@link Mockito#lenient()}.
 * Let us know how do you find the new feature by opening a GitHub issue to discuss!
 */
@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L1538">public class Mockito extends ArgumentMatchers {</span>

<span class="fc" id="L1540">    static final MockitoCore MOCKITO_CORE = new MockitoCore();</span>

    /**
     * The default &lt;code&gt;Answer&lt;/code&gt; of every mock &lt;b&gt;if&lt;/b&gt; the mock was not stubbed.
     *
     * Typically it just returns some empty value.
     * &lt;p&gt;
     * {@link Answer} can be used to define the return values of unstubbed invocations.
     * &lt;p&gt;
     * This implementation first tries the global configuration and if there is no global configuration then
     * it will use a default answer that returns zeros, empty collections, nulls, etc.
     */
<span class="fc" id="L1552">    public static final Answer&lt;Object&gt; RETURNS_DEFAULTS = Answers.RETURNS_DEFAULTS;</span>

    /**
     * Optional &lt;code&gt;Answer&lt;/code&gt; to be used with {@link Mockito#mock(Class, Answer)}.
     * &lt;p&gt;
     * {@link Answer} can be used to define the return values of unstubbed invocations.
     * &lt;p&gt;
     * This implementation can be helpful when working with legacy code.
     * Unstubbed methods often return null. If your code uses the object returned by an unstubbed call you get a NullPointerException.
     * This implementation of Answer &lt;b&gt;returns SmartNull instead of null&lt;/b&gt;.
     * &lt;code&gt;SmartNull&lt;/code&gt; gives nicer exception message than NPE because it points out the line where unstubbed method was called. You just click on the stack trace.
     * &lt;p&gt;
     * &lt;code&gt;ReturnsSmartNulls&lt;/code&gt; first tries to return ordinary values (zeros, empty collections, empty string, etc.)
     * then it tries to return SmartNull. If the return type is final then plain &lt;code&gt;null&lt;/code&gt; is returned.
     * &lt;p&gt;
     * &lt;code&gt;ReturnsSmartNulls&lt;/code&gt; will be probably the default return values strategy in Mockito 3.0.0
     * &lt;p&gt;
     * Example:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   Foo mock = mock(Foo.class, RETURNS_SMART_NULLS);
     *
     *   //calling unstubbed method here:
     *   Stuff stuff = mock.getStuff();
     *
     *   //using object returned by unstubbed call:
     *   stuff.doSomething();
     *
     *   //Above doesn't yield NullPointerException this time!
     *   //Instead, SmartNullPointerException is thrown.
     *   //Exception's cause links to unstubbed &lt;i&gt;mock.getStuff()&lt;/i&gt; - just click on the stack trace.
     * &lt;/code&gt;&lt;/pre&gt;
     */
<span class="fc" id="L1584">    public static final Answer&lt;Object&gt; RETURNS_SMART_NULLS = Answers.RETURNS_SMART_NULLS;</span>

    /**
     * Optional &lt;code&gt;Answer&lt;/code&gt; to be used with {@link Mockito#mock(Class, Answer)}
     * &lt;p&gt;
     * {@link Answer} can be used to define the return values of unstubbed invocations.
     * &lt;p&gt;
     * This implementation can be helpful when working with legacy code.
     * &lt;p&gt;
     * ReturnsMocks first tries to return ordinary values (zeros, empty collections, empty string, etc.)
     * then it tries to return mocks. If the return type cannot be mocked (e.g. is final) then plain &lt;code&gt;null&lt;/code&gt; is returned.
     * &lt;p&gt;
     */
<span class="fc" id="L1597">    public static final Answer&lt;Object&gt; RETURNS_MOCKS = Answers.RETURNS_MOCKS;</span>

    /**
     * Optional &lt;code&gt;Answer&lt;/code&gt; to be used with {@link Mockito#mock(Class, Answer)}.
     * &lt;p&gt;
     * Example that shows how deep stub works:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   Foo mock = mock(Foo.class, RETURNS_DEEP_STUBS);
     *
     *   // note that we're stubbing a chain of methods here: getBar().getName()
     *   when(mock.getBar().getName()).thenReturn(&quot;deep&quot;);
     *
     *   // note that we're chaining method calls: getBar().getName()
     *   assertEquals(&quot;deep&quot;, mock.getBar().getName());
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * &lt;strong&gt;WARNING: &lt;/strong&gt;
     * This feature should rarely be required for regular clean code! Leave it for legacy code.
     * Mocking a mock to return a mock, to return a mock, (...), to return something meaningful
     * hints at violation of Law of Demeter or mocking a value object (a well known anti-pattern).
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Good quote I've seen one day on the web: &lt;strong&gt;every time a mock returns a mock a fairy dies&lt;/strong&gt;.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Please note that this answer will return existing mocks that matches the stub. This
     * behavior is ok with deep stubs and allows verification to work on the last mock of the chain.
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   when(mock.getBar(anyString()).getThingy().getName()).thenReturn(&quot;deep&quot;);
     *
     *   mock.getBar(&quot;candy bar&quot;).getThingy().getName();
     *
     *   assertSame(mock.getBar(anyString()).getThingy().getName(), mock.getBar(anyString()).getThingy().getName());
     *   verify(mock.getBar(&quot;candy bar&quot;).getThingy()).getName();
     *   verify(mock.getBar(anyString()).getThingy()).getName();
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Verification only works with the last mock in the chain. You can use verification modes.
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   when(person.getAddress(anyString()).getStreet().getName()).thenReturn(&quot;deep&quot;);
     *   when(person.getAddress(anyString()).getStreet(Locale.ITALIAN).getName()).thenReturn(&quot;deep&quot;);
     *   when(person.getAddress(anyString()).getStreet(Locale.CHINESE).getName()).thenReturn(&quot;deep&quot;);
     *
     *   person.getAddress(&quot;the docks&quot;).getStreet().getName();
     *   person.getAddress(&quot;the docks&quot;).getStreet().getLongName();
     *   person.getAddress(&quot;the docks&quot;).getStreet(Locale.ITALIAN).getName();
     *   person.getAddress(&quot;the docks&quot;).getStreet(Locale.CHINESE).getName();
     *
     *   // note that we are actually referring to the very last mock in the stubbing chain.
     *   InOrder inOrder = inOrder(
     *       person.getAddress(&quot;the docks&quot;).getStreet(),
     *       person.getAddress(&quot;the docks&quot;).getStreet(Locale.CHINESE),
     *       person.getAddress(&quot;the docks&quot;).getStreet(Locale.ITALIAN)
     *   );
     *   inOrder.verify(person.getAddress(&quot;the docks&quot;).getStreet(), times(1)).getName();
     *   inOrder.verify(person.getAddress(&quot;the docks&quot;).getStreet()).getLongName();
     *   inOrder.verify(person.getAddress(&quot;the docks&quot;).getStreet(Locale.ITALIAN), atLeast(1)).getName();
     *   inOrder.verify(person.getAddress(&quot;the docks&quot;).getStreet(Locale.CHINESE)).getName();
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * How deep stub work internally?
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   //this:
     *   Foo mock = mock(Foo.class, RETURNS_DEEP_STUBS);
     *   when(mock.getBar().getName(), &quot;deep&quot;);
     *
     *   //is equivalent of
     *   Foo foo = mock(Foo.class);
     *   Bar bar = mock(Bar.class);
     *   when(foo.getBar()).thenReturn(bar);
     *   when(bar.getName()).thenReturn(&quot;deep&quot;);
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * This feature will not work when any return type of methods included in the chain cannot be mocked
     * (for example: is a primitive or a final class). This is because of java type system.
     * &lt;/p&gt;
     */
<span class="fc" id="L1684">    public static final Answer&lt;Object&gt; RETURNS_DEEP_STUBS = Answers.RETURNS_DEEP_STUBS;</span>

    /**
     * Optional &lt;code&gt;Answer&lt;/code&gt; to be used with {@link Mockito#mock(Class, Answer)}
     * &lt;p&gt;
     * {@link Answer} can be used to define the return values of unstubbed invocations.
     * &lt;p&gt;
     * This implementation can be helpful when working with legacy code.
     * When this implementation is used, unstubbed methods will delegate to the real implementation.
     * This is a way to create a partial mock object that calls real methods by default.
     * &lt;p&gt;
     * As usual you are going to read &lt;b&gt;the partial mock warning&lt;/b&gt;:
     * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.
     * How does partial mock fit into this paradigm? Well, it just doesn't...
     * Partial mock usually means that the complexity has been moved to a different method on the same object.
     * In most cases, this is not the way you want to design your application.
     * &lt;p&gt;
     * However, there are rare cases when partial mocks come handy:
     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
     * However, I wouldn't use partial mocks for new, test-driven &amp; well-designed code.
     * &lt;p&gt;
     * Example:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     * Foo mock = mock(Foo.class, CALLS_REAL_METHODS);
     *
     * // this calls the real implementation of Foo.getSomething()
     * value = mock.getSomething();
     *
     * doReturn(fakeValue).when(mock).getSomething();
     *
     * // now fakeValue is returned
     * value = mock.getSomething();
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * &lt;p&gt;
     * &lt;u&gt;Note:&lt;/u&gt; Stubbing partial mocks using &lt;code&gt;when(mock.getSomething()).thenReturn(fakeValue)&lt;/code&gt;
     * syntax will call the real method. For partial mock it's recommended to use &lt;code&gt;doReturn&lt;/code&gt; syntax.
     */
<span class="fc" id="L1722">    public static final Answer&lt;Object&gt; CALLS_REAL_METHODS = Answers.CALLS_REAL_METHODS;</span>

    /**
     * Optional &lt;code&gt;Answer&lt;/code&gt; to be used with {@link Mockito#mock(Class, Answer)}.
     *
     * Allows Builder mocks to return itself whenever a method is invoked that returns a Type equal
     * to the class or a superclass.
     *
     * &lt;p&gt;&lt;b&gt;Keep in mind this answer uses the return type of a method.
     * If this type is assignable to the class of the mock, it will return the mock.
     * Therefore if you have a method returning a superclass (for example {@code Object}) it will match and return the mock.&lt;/b&gt;&lt;/p&gt;
     *
     * Consider a HttpBuilder used in a HttpRequesterWithHeaders.
     *
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     * public class HttpRequesterWithHeaders {
     *
     *      private HttpBuilder builder;
     *
     *      public HttpRequesterWithHeaders(HttpBuilder builder) {
     *          this.builder = builder;
     *      }
     *
     *      public String request(String uri) {
     *          return builder.withUrl(uri)
     *                  .withHeader(&quot;Content-type: application/json&quot;)
     *                  .withHeader(&quot;Authorization: Bearer&quot;)
     *                  .request();
     *      }
     *  }
     *
     *  private static class HttpBuilder {
     *
     *      private String uri;
     *      private List&amp;lt;String&amp;gt; headers;
     *
     *      public HttpBuilder() {
     *          this.headers = new ArrayList&amp;lt;String&amp;gt;();
     *      }
     *
     *       public HttpBuilder withUrl(String uri) {
     *           this.uri = uri;
     *           return this;
     *       }
     *
     *       public HttpBuilder withHeader(String header) {
     *           this.headers.add(header);
     *           return this;
     *       }
     *
     *       public String request() {
     *          return uri + headers.toString();
     *       }
     *  }
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * The following test will succeed
     *
     * &lt;pre&gt;&lt;code&gt;
     * &amp;#064;Test
     *  public void use_full_builder_with_terminating_method() {
     *      HttpBuilder builder = mock(HttpBuilder.class, RETURNS_SELF);
     *      HttpRequesterWithHeaders requester = new HttpRequesterWithHeaders(builder);
     *      String response = &quot;StatusCode: 200&quot;;
     *
     *      when(builder.request()).thenReturn(response);
     *
     *      assertThat(requester.request(&quot;URI&quot;)).isEqualTo(response);
     *  }
     * &lt;/code&gt;&lt;/pre&gt;
     */
<span class="fc" id="L1793">    public static final Answer&lt;Object&gt; RETURNS_SELF = Answers.RETURNS_SELF;</span>

    /**
     * Creates mock object of given class or interface.
     * &lt;p&gt;
     * See examples in javadoc for {@link Mockito} class
     *
     * @param classToMock class or interface to mock
     * @return mock object
     */
    @CheckReturnValue
    public static &lt;T&gt; T mock(Class&lt;T&gt; classToMock) {
<span class="fc" id="L1805">        return mock(classToMock, withSettings());</span>
    }

    /**
     * Specifies mock name. Naming mocks can be helpful for debugging - the name is used in all verification errors.
     * &lt;p&gt;
     * Beware that naming mocks is not a solution for complex code which uses too many mocks or collaborators.
     * &lt;b&gt;If you have too many mocks then refactor the code&lt;/b&gt; so that it's easy to test/debug without necessity of naming mocks.
     * &lt;p&gt;
     * &lt;b&gt;If you use &lt;code&gt;&amp;#064;Mock&lt;/code&gt; annotation then you've got naming mocks for free!&lt;/b&gt; &lt;code&gt;&amp;#064;Mock&lt;/code&gt; uses field name as mock name. {@link Mock Read more.}
     * &lt;p&gt;
     *
     * See examples in javadoc for {@link Mockito} class
     *
     * @param classToMock class or interface to mock
     * @param name of the mock
     * @return mock object
     */
    @CheckReturnValue
    public static &lt;T&gt; T mock(Class&lt;T&gt; classToMock, String name) {
<span class="fc" id="L1825">        return mock(classToMock, withSettings()</span>
<span class="fc" id="L1826">                .name(name)</span>
<span class="fc" id="L1827">                .defaultAnswer(RETURNS_DEFAULTS));</span>
    }

    /**
     * Returns a MockingDetails instance that enables inspecting a particular object for Mockito related information.
     * Can be used to find out if given object is a Mockito mock
     * or to find out if a given mock is a spy or mock.
     * &lt;p&gt;
     * In future Mockito versions MockingDetails may grow and provide other useful information about the mock,
     * e.g. invocations, stubbing info, etc.
     *
     * @param toInspect - object to inspect. null input is allowed.
     * @return A {@link org.mockito.MockingDetails} instance.
     * @since 1.9.5
     */
    @CheckReturnValue
    public static MockingDetails mockingDetails(Object toInspect) {
<span class="fc" id="L1844">        return MOCKITO_CORE.mockingDetails(toInspect);</span>
    }

    /**
     * Creates mock with a specified strategy for its answers to interactions.
     * It's quite an advanced feature and typically you don't need it to write decent tests.
     * However it can be helpful when working with legacy systems.
     * &lt;p&gt;
     * It is the default answer so it will be used &lt;b&gt;only when you don't&lt;/b&gt; stub the method call.
     *
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   Foo mock = mock(Foo.class, RETURNS_SMART_NULLS);
     *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer());
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * &lt;p&gt;See examples in javadoc for {@link Mockito} class&lt;/p&gt;
     *
     * @param classToMock class or interface to mock
     * @param defaultAnswer default answer for unstubbed methods
     *
     * @return mock object
     */
    @CheckReturnValue
    public static &lt;T&gt; T mock(Class&lt;T&gt; classToMock, Answer defaultAnswer) {
<span class="fc" id="L1868">        return mock(classToMock, withSettings().defaultAnswer(defaultAnswer));</span>
    }

    /**
     * Creates a mock with some non-standard settings.
     * &lt;p&gt;
     * The number of configuration points for a mock grows
     * so we need a fluent way to introduce new configuration without adding more and more overloaded Mockito.mock() methods.
     * Hence {@link MockSettings}.
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   Listener mock = mock(Listener.class, withSettings()
     *     .name(&quot;firstListner&quot;).defaultBehavior(RETURNS_SMART_NULLS));
     *   );
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;b&gt;Use it carefully and occasionally&lt;/b&gt;. What might be reason your test needs non-standard mocks?
     * Is the code under test so complicated that it requires non-standard mocks?
     * Wouldn't you prefer to refactor the code under test so it is testable in a simple way?
     * &lt;p&gt;
     * See also {@link Mockito#withSettings()}
     * &lt;p&gt;
     * See examples in javadoc for {@link Mockito} class
     *
     * @param classToMock class or interface to mock
     * @param mockSettings additional mock settings
     * @return mock object
     */
    @CheckReturnValue
    public static &lt;T&gt; T mock(Class&lt;T&gt; classToMock, MockSettings mockSettings) {
<span class="fc" id="L1896">        return MOCKITO_CORE.mock(classToMock, mockSettings);</span>
    }

    /**
     * Creates a spy of the real object. The spy calls &lt;b&gt;real&lt;/b&gt; methods unless they are stubbed.
     * &lt;p&gt;
     * Real spies should be used &lt;b&gt;carefully and occasionally&lt;/b&gt;, for example when dealing with legacy code.
     * &lt;p&gt;
     * As usual you are going to read &lt;b&gt;the partial mock warning&lt;/b&gt;:
     * Object oriented programming tackles complexity by dividing the complexity into separate, specific, SRPy objects.
     * How does partial mock fit into this paradigm? Well, it just doesn't...
     * Partial mock usually means that the complexity has been moved to a different method on the same object.
     * In most cases, this is not the way you want to design your application.
     * &lt;p&gt;
     * However, there are rare cases when partial mocks come handy:
     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
     * However, I wouldn't use partial mocks for new, test-driven &amp; well-designed code.
     * &lt;p&gt;
     * Example:
     *
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   List list = new LinkedList();
     *   List spy = spy(list);
     *
     *   //optionally, you can stub out some methods:
     *   when(spy.size()).thenReturn(100);
     *
     *   //using the spy calls &lt;b&gt;real&lt;/b&gt; methods
     *   spy.add(&quot;one&quot;);
     *   spy.add(&quot;two&quot;);
     *
     *   //prints &quot;one&quot; - the first element of a list
     *   System.out.println(spy.get(0));
     *
     *   //size() method was stubbed - 100 is printed
     *   System.out.println(spy.size());
     *
     *   //optionally, you can verify
     *   verify(spy).add(&quot;one&quot;);
     *   verify(spy).add(&quot;two&quot;);
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * &lt;h4&gt;Important gotcha on spying real objects!&lt;/h4&gt;
     * &lt;ol&gt;
     * &lt;li&gt;Sometimes it's impossible or impractical to use {@link Mockito#when(Object)} for stubbing spies.
     * Therefore for spies it is recommended to always use &lt;code&gt;doReturn&lt;/code&gt;|&lt;code&gt;Answer&lt;/code&gt;|&lt;code&gt;Throw()&lt;/code&gt;|&lt;code&gt;CallRealMethod&lt;/code&gt;
     * family of methods for stubbing. Example:
     *
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   List list = new LinkedList();
     *   List spy = spy(list);
     *
     *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)
     *   when(spy.get(0)).thenReturn(&quot;foo&quot;);
     *
     *   //You have to use doReturn() for stubbing
     *   doReturn(&quot;foo&quot;).when(spy).get(0);
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;/li&gt;
     *
     * &lt;li&gt;Mockito &lt;b&gt;*does not*&lt;/b&gt; delegate calls to the passed real instance, instead it actually creates a copy of it.
     * So if you keep the real instance and interact with it, don't expect the spied to be aware of those interaction
     * and their effect on real instance state.
     * The corollary is that when an &lt;b&gt;*unstubbed*&lt;/b&gt; method is called &lt;b&gt;*on the spy*&lt;/b&gt; but &lt;b&gt;*not on the real instance*&lt;/b&gt;,
     * you won't see any effects on the real instance.&lt;/li&gt;
     *
     * &lt;li&gt;Watch out for final methods.
     * Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.
     * Also you won't be able to verify those method as well.
     * &lt;/li&gt;
     * &lt;/ol&gt;
     * &lt;p&gt;
     * See examples in javadoc for {@link Mockito} class
     *
     * &lt;p&gt;Note that the spy won't have any annotations of the spied type, because CGLIB won't rewrite them.
     * It may troublesome for code that rely on the spy to have these annotations.&lt;/p&gt;
     *
     *
     * @param object
     *            to spy on
     * @return a spy of the real object
     */
    @CheckReturnValue
    public static &lt;T&gt; T spy(T object) {
<span class="fc" id="L1980">        return MOCKITO_CORE.mock((Class&lt;T&gt;) object.getClass(), withSettings()</span>
<span class="fc" id="L1981">                .spiedInstance(object)</span>
<span class="fc" id="L1982">                .defaultAnswer(CALLS_REAL_METHODS));</span>
    }

    /**
     * Please refer to the documentation of {@link #spy(Object)}.
     * Overusing spies hints at code design smells.
     * &lt;p&gt;
     * This method, in contrast to the original {@link #spy(Object)}, creates a spy based on class instead of an object.
     * Sometimes it is more convenient to create spy based on the class and avoid providing an instance of a spied object.
     * This is particularly useful for spying on abstract classes because they cannot be instantiated.
     * See also {@link MockSettings#useConstructor(Object...)}.
     * &lt;p&gt;
     * Examples:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   SomeAbstract spy = spy(SomeAbstract.class);
     *
     *   //Robust API, via settings builder:
     *   OtherAbstract spy = mock(OtherAbstract.class, withSettings()
     *      .useConstructor().defaultAnswer(CALLS_REAL_METHODS));
     *
     *   //Mocking a non-static inner abstract class:
     *   InnerAbstract spy = mock(InnerAbstract.class, withSettings()
     *      .useConstructor().outerInstance(outerInstance).defaultAnswer(CALLS_REAL_METHODS));
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * @param classToSpy the class to spy
     * @param &lt;T&gt; type of the spy
     * @return a spy of the provided class
     * @since 1.10.12
     */
    @Incubating
    @CheckReturnValue
    public static &lt;T&gt; T spy(Class&lt;T&gt; classToSpy) {
<span class="fc" id="L2015">        return MOCKITO_CORE.mock(classToSpy, withSettings()</span>
<span class="fc" id="L2016">                .useConstructor()</span>
<span class="fc" id="L2017">                .defaultAnswer(CALLS_REAL_METHODS));</span>
    }

    /**
     * Enables stubbing methods. Use it when you want the mock to return particular value when particular method is called.
     * &lt;p&gt;
     * Simply put: &quot;&lt;b&gt;When&lt;/b&gt; the x method is called &lt;b&gt;then&lt;/b&gt; return y&quot;.
     *
     * &lt;p&gt;
     * Examples:
     *
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     * &lt;b&gt;when&lt;/b&gt;(mock.someMethod()).&lt;b&gt;thenReturn&lt;/b&gt;(10);
     *
     * //you can use flexible argument matchers, e.g:
     * when(mock.someMethod(&lt;b&gt;anyString()&lt;/b&gt;)).thenReturn(10);
     *
     * //setting exception to be thrown:
     * when(mock.someMethod(&quot;some arg&quot;)).thenThrow(new RuntimeException());
     *
     * //you can set different behavior for consecutive method calls.
     * //Last stubbing (e.g: thenReturn(&quot;foo&quot;)) determines the behavior of further consecutive calls.
     * when(mock.someMethod(&quot;some arg&quot;))
     *  .thenThrow(new RuntimeException())
     *  .thenReturn(&quot;foo&quot;);
     *
     * //Alternative, shorter version for consecutive stubbing:
     * when(mock.someMethod(&quot;some arg&quot;))
     *  .thenReturn(&quot;one&quot;, &quot;two&quot;);
     * //is the same as:
     * when(mock.someMethod(&quot;some arg&quot;))
     *  .thenReturn(&quot;one&quot;)
     *  .thenReturn(&quot;two&quot;);
     *
     * //shorter version for consecutive method calls throwing exceptions:
     * when(mock.someMethod(&quot;some arg&quot;))
     *  .thenThrow(new RuntimeException(), new NullPointerException();
     *
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * For stubbing void methods with throwables see: {@link Mockito#doThrow(Throwable...)}
     * &lt;p&gt;
     * Stubbing can be overridden: for example common stubbing can go to fixture
     * setup but the test methods can override it.
     * Please note that overridding stubbing is a potential code smell that points out too much stubbing.
     * &lt;p&gt;
     * Once stubbed, the method will always return stubbed value regardless
     * of how many times it is called.
     * &lt;p&gt;
     * Last stubbing is more important - when you stubbed the same method with
     * the same arguments many times.
     * &lt;p&gt;
     * Although it is possible to verify a stubbed invocation, usually &lt;b&gt;it's just redundant&lt;/b&gt;.
     * Let's say you've stubbed &lt;code&gt;foo.bar()&lt;/code&gt;.
     * If your code cares what &lt;code&gt;foo.bar()&lt;/code&gt; returns then something else breaks(often before even &lt;code&gt;verify()&lt;/code&gt; gets executed).
     * If your code doesn't care what &lt;code&gt;get(0)&lt;/code&gt; returns then it should not be stubbed.
     * Not convinced? See &lt;a href=&quot;http://monkeyisland.pl/2008/04/26/asking-and-telling&quot;&gt;here&lt;/a&gt;.
     *
     * &lt;p&gt;
     * See examples in javadoc for {@link Mockito} class
     * @param methodCall method to be stubbed
     * @return OngoingStubbing object used to stub fluently.
     *         &lt;strong&gt;Do not&lt;/strong&gt; create a reference to this returned object.
     */
    @CheckReturnValue
    public static &lt;T&gt; OngoingStubbing&lt;T&gt; when(T methodCall) {
<span class="fc" id="L2083">        return MOCKITO_CORE.when(methodCall);</span>
    }

    /**
     * Verifies certain behavior &lt;b&gt;happened once&lt;/b&gt;.
     * &lt;p&gt;
     * Alias to &lt;code&gt;verify(mock, times(1))&lt;/code&gt; E.g:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   verify(mock).someMethod(&quot;some arg&quot;);
     * &lt;/code&gt;&lt;/pre&gt;
     * Above is equivalent to:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   verify(mock, times(1)).someMethod(&quot;some arg&quot;);
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;p&gt;
     * Arguments passed are compared using &lt;code&gt;equals()&lt;/code&gt; method.
     * Read about {@link ArgumentCaptor} or {@link ArgumentMatcher} to find out other ways of matching / asserting arguments passed.
     * &lt;p&gt;
     * Although it is possible to verify a stubbed invocation, usually &lt;b&gt;it's just redundant&lt;/b&gt;.
     * Let's say you've stubbed &lt;code&gt;foo.bar()&lt;/code&gt;.
     * If your code cares what &lt;code&gt;foo.bar()&lt;/code&gt; returns then something else breaks(often before even &lt;code&gt;verify()&lt;/code&gt; gets executed).
     * If your code doesn't care what &lt;code&gt;get(0)&lt;/code&gt; returns then it should not be stubbed.
     * Not convinced? See &lt;a href=&quot;http://monkeyisland.pl/2008/04/26/asking-and-telling&quot;&gt;here&lt;/a&gt;.
     *
     * &lt;p&gt;
     * See examples in javadoc for {@link Mockito} class
     *
     * @param mock to be verified
     * @return mock object itself
     */
    @CheckReturnValue
    public static &lt;T&gt; T verify(T mock) {
<span class="fc" id="L2115">        return MOCKITO_CORE.verify(mock, times(1));</span>
    }

    /**
     * Verifies certain behavior happened at least once / exact number of times / never. E.g:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   verify(mock, times(5)).someMethod(&quot;was called five times&quot;);
     *
     *   verify(mock, atLeast(2)).someMethod(&quot;was called at least two times&quot;);
     *
     *   //you can use flexible argument matchers, e.g:
     *   verify(mock, atLeastOnce()).someMethod(&lt;b&gt;anyString()&lt;/b&gt;);
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * &lt;b&gt;times(1) is the default&lt;/b&gt; and can be omitted
     * &lt;p&gt;
     * Arguments passed are compared using &lt;code&gt;equals()&lt;/code&gt; method.
     * Read about {@link ArgumentCaptor} or {@link ArgumentMatcher} to find out other ways of matching / asserting arguments passed.
     * &lt;p&gt;
     *
     * @param mock to be verified
     * @param mode times(x), atLeastOnce() or never()
     *
     * @return mock object itself
     */
    @CheckReturnValue
    public static &lt;T&gt; T verify(T mock, VerificationMode mode) {
<span class="fc" id="L2142">        return MOCKITO_CORE.verify(mock, mode);</span>
    }

    /**
     * Smart Mockito users hardly use this feature because they know it could be a sign of poor tests.
     * Normally, you don't need to reset your mocks, just create new mocks for each test method.
     * &lt;p&gt;
     * Instead of &lt;code&gt;#reset()&lt;/code&gt; please consider writing simple, small and focused test methods over lengthy, over-specified tests.
     * &lt;b&gt;First potential code smell is &lt;code&gt;reset()&lt;/code&gt; in the middle of the test method.&lt;/b&gt; This probably means you're testing too much.
     * Follow the whisper of your test methods: &quot;Please keep us small &amp; focused on single behavior&quot;.
     * There are several threads about it on mockito mailing list.
     * &lt;p&gt;
     * The only reason we added &lt;code&gt;reset()&lt;/code&gt; method is to
     * make it possible to work with container-injected mocks.
     * For more information see the FAQ (&lt;a href=&quot;https://github.com/mockito/mockito/wiki/FAQ&quot;&gt;here&lt;/a&gt;).
     * &lt;p&gt;
     * &lt;b&gt;Don't harm yourself.&lt;/b&gt; &lt;code&gt;reset()&lt;/code&gt; in the middle of the test method is a code smell (you're probably testing too much).
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   List mock = mock(List.class);
     *   when(mock.size()).thenReturn(10);
     *   mock.add(1);
     *
     *   reset(mock);
     *   //at this point the mock forgot any interactions &amp; stubbing
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * @param &lt;T&gt; The Type of the mocks
     * @param mocks to be reset
     */
    public static &lt;T&gt; void reset(T ... mocks) {
<span class="fc" id="L2172">        MOCKITO_CORE.reset(mocks);</span>
<span class="fc" id="L2173">    }</span>

    /**
     * Use this method in order to only clear invocations, when stubbing is non-trivial. Use-cases can be:
     * &lt;ul&gt;
     *     &lt;li&gt;You are using a dependency injection framework to inject your mocks.&lt;/li&gt;
     *     &lt;li&gt;The mock is used in a stateful scenario. For example a class is Singleton which depends on your mock.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;b&gt;Try to avoid this method at all costs. Only clear invocations if you are unable to efficiently test your program.&lt;/b&gt;
     * @param &lt;T&gt; The type of the mocks
     * @param mocks The mocks to clear the invocations for
     */
    public static &lt;T&gt; void clearInvocations(T ... mocks) {
<span class="fc" id="L2187">        MOCKITO_CORE.clearInvocations(mocks);</span>
<span class="fc" id="L2188">    }</span>

    /**
     * Checks if any of given mocks has any unverified interaction.
     * &lt;p&gt;
     * You can use this method after you verified your mocks - to make sure that nothing
     * else was invoked on your mocks.
     * &lt;p&gt;
     * See also {@link Mockito#never()} - it is more explicit and communicates the intent well.
     * &lt;p&gt;
     * Stubbed invocations (if called) are also treated as interactions.
     * If you want stubbed invocations automatically verified, check out {@link Strictness#STRICT_STUBS} feature
     * introduced in Mockito 2.3.0.
     * If you want to ignore stubs for verification, see {@link #ignoreStubs(Object...)}.
     * &lt;p&gt;
     * A word of &lt;b&gt;warning&lt;/b&gt;:
     * Some users who did a lot of classic, expect-run-verify mocking tend to use &lt;code&gt;verifyNoMoreInteractions()&lt;/code&gt; very often, even in every test method.
     * &lt;code&gt;verifyNoMoreInteractions()&lt;/code&gt; is not recommended to use in every test method.
     * &lt;code&gt;verifyNoMoreInteractions()&lt;/code&gt; is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.
     * Abusing it leads to overspecified, less maintainable tests. You can find further reading
     * &lt;a href=&quot;http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/&quot;&gt;here&lt;/a&gt;.
     * &lt;p&gt;
     * This method will also detect unverified invocations that occurred before the test method,
     * for example: in &lt;code&gt;setUp()&lt;/code&gt;, &lt;code&gt;&amp;#064;Before&lt;/code&gt; method or in constructor.
     * Consider writing nice code that makes interactions only in test methods.
     *
     * &lt;p&gt;
     * Example:
     *
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     * //interactions
     * mock.doSomething();
     * mock.doSomethingUnexpected();
     *
     * //verification
     * verify(mock).doSomething();
     *
     * //following will fail because 'doSomethingUnexpected()' is unexpected
     * verifyNoMoreInteractions(mock);
     *
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * See examples in javadoc for {@link Mockito} class
     *
     * @param mocks to be verified
     */
    public static void verifyNoMoreInteractions(Object... mocks) {
<span class="fc" id="L2235">        MOCKITO_CORE.verifyNoMoreInteractions(mocks);</span>
<span class="fc" id="L2236">    }</span>

    /**
     * Verifies that no interactions happened on given mocks beyond the previously verified interactions.&lt;br/&gt;
     * This method has the same behavior as {@link #verifyNoMoreInteractions(Object...)}.
     *
     * @param mocks to be verified
     */
    public static void verifyZeroInteractions(Object... mocks) {
<span class="fc" id="L2245">        MOCKITO_CORE.verifyNoMoreInteractions(mocks);</span>
<span class="fc" id="L2246">    }</span>

    /**
     * Use &lt;code&gt;doThrow()&lt;/code&gt; when you want to stub the void method with an exception.
     * &lt;p&gt;
     * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler
     * does not like void methods inside brackets...
     * &lt;p&gt;
     * Example:
     *
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   doThrow(new RuntimeException()).when(mock).someVoidMethod();
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * @param toBeThrown to be thrown when the stubbed method is called
     * @return stubber - to select a method for stubbing
     */
    @CheckReturnValue
    public static Stubber doThrow(Throwable... toBeThrown) {
<span class="fc" id="L2265">        return MOCKITO_CORE.stubber().doThrow(toBeThrown);</span>
    }

    /**
     * Use &lt;code&gt;doThrow()&lt;/code&gt; when you want to stub the void method with an exception.
     * &lt;p&gt;
     * A new exception instance will be created for each method invocation.
     * &lt;p&gt;
     * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler
     * does not like void methods inside brackets...
     * &lt;p&gt;
     * Example:
     *
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   doThrow(RuntimeException.class).when(mock).someVoidMethod();
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * @param toBeThrown to be thrown when the stubbed method is called
     * @return stubber - to select a method for stubbing
     * @since 2.1.0
     */
    @CheckReturnValue
    public static Stubber doThrow(Class&lt;? extends Throwable&gt; toBeThrown) {
<span class="fc" id="L2288">        return MOCKITO_CORE.stubber().doThrow(toBeThrown);</span>
    }

    /**
     * Same as {@link #doThrow(Class)} but sets consecutive exception classes to be thrown. Remember to use
     * &lt;code&gt;doThrow()&lt;/code&gt; when you want to stub the void method to throw several exception of specified class.
     * &lt;p&gt;
     * A new exception instance will be created for each method invocation.
     * &lt;p&gt;
     * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler
     * does not like void methods inside brackets...
     * &lt;p&gt;
     * Example:
     *
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   doThrow(RuntimeException.class, BigFailure.class).when(mock).someVoidMethod();
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * @param toBeThrown to be thrown when the stubbed method is called
     * @param toBeThrownNext next to be thrown when the stubbed method is called
     * @return stubber - to select a method for stubbing
     * @since 2.1.0
     */
    // Additional method helps users of JDK7+ to hide heap pollution / unchecked generics array creation
    @SuppressWarnings ({&quot;unchecked&quot;, &quot;varargs&quot;})
    @CheckReturnValue
    public static Stubber doThrow(Class&lt;? extends Throwable&gt; toBeThrown, Class&lt;? extends Throwable&gt;... toBeThrownNext) {
<span class="fc" id="L2315">        return MOCKITO_CORE.stubber().doThrow(toBeThrown, toBeThrownNext);</span>
    }


    /**
     * Use &lt;code&gt;doCallRealMethod()&lt;/code&gt; when you want to call the real implementation of a method.
     * &lt;p&gt;
     * As usual you are going to read &lt;b&gt;the partial mock warning&lt;/b&gt;:
     * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.
     * How does partial mock fit into this paradigm? Well, it just doesn't...
     * Partial mock usually means that the complexity has been moved to a different method on the same object.
     * In most cases, this is not the way you want to design your application.
     * &lt;p&gt;
     * However, there are rare cases when partial mocks come handy:
     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
     * However, I wouldn't use partial mocks for new, test-driven &amp; well-designed code.
     * &lt;p&gt;
     * See also javadoc {@link Mockito#spy(Object)} to find out more about partial mocks.
     * &lt;b&gt;Mockito.spy() is a recommended way of creating partial mocks.&lt;/b&gt;
     * The reason is it guarantees real methods are called against correctly constructed object because you're responsible for constructing the object passed to spy() method.
     * &lt;p&gt;
     * Example:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   Foo mock = mock(Foo.class);
     *   doCallRealMethod().when(mock).someVoidMethod();
     *
     *   // this will call the real implementation of Foo.someVoidMethod()
     *   mock.someVoidMethod();
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;p&gt;
     * See examples in javadoc for {@link Mockito} class
     *
     * @return stubber - to select a method for stubbing
     * @since 1.9.5
     */
    @CheckReturnValue
    public static Stubber doCallRealMethod() {
<span class="fc" id="L2352">        return MOCKITO_CORE.stubber().doCallRealMethod();</span>
    }

    /**
     * Use &lt;code&gt;doAnswer()&lt;/code&gt; when you want to stub a void method with generic {@link Answer}.
     * &lt;p&gt;
     * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...
     * &lt;p&gt;
     * Example:
     *
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *  doAnswer(new Answer() {
     *      public Object answer(InvocationOnMock invocation) {
     *          Object[] args = invocation.getArguments();
     *          Mock mock = invocation.getMock();
     *          return null;
     *      }})
     *  .when(mock).someMethod();
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;p&gt;
     * See examples in javadoc for {@link Mockito} class
     *
     * @param answer to answer when the stubbed method is called
     * @return stubber - to select a method for stubbing
     */
    @CheckReturnValue
    public static Stubber doAnswer(Answer answer) {
<span class="fc" id="L2379">        return MOCKITO_CORE.stubber().doAnswer(answer);</span>
    }

    /**
     * Use &lt;code&gt;doNothing()&lt;/code&gt; for setting void methods to do nothing. &lt;b&gt;Beware that void methods on mocks do nothing by default!&lt;/b&gt;
     * However, there are rare situations when doNothing() comes handy:
     * &lt;p&gt;
     * &lt;ol&gt;
     * &lt;li&gt;Stubbing consecutive calls on a void method:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   doNothing().
     *   doThrow(new RuntimeException())
     *   .when(mock).someVoidMethod();
     *
     *   //does nothing the first time:
     *   mock.someVoidMethod();
     *
     *   //throws RuntimeException the next time:
     *   mock.someVoidMethod();
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;/li&gt;
     * &lt;li&gt;When you spy real objects and you want the void method to do nothing:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   List list = new LinkedList();
     *   List spy = spy(list);
     *
     *   //let's make clear() do nothing
     *   doNothing().when(spy).clear();
     *
     *   spy.add(&quot;one&quot;);
     *
     *   //clear() does nothing, so the list still contains &quot;one&quot;
     *   spy.clear();
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;/li&gt;
     * &lt;/ol&gt;
     * &lt;p&gt;
     * See examples in javadoc for {@link Mockito} class
     *
     * @return stubber - to select a method for stubbing
     */
    @CheckReturnValue
    public static Stubber doNothing() {
<span class="fc" id="L2422">        return MOCKITO_CORE.stubber().doNothing();</span>
    }

    /**
     * Use &lt;code&gt;doReturn()&lt;/code&gt; in those rare occasions when you cannot use {@link Mockito#when(Object)}.
     * &lt;p&gt;
     * &lt;b&gt;Beware that {@link Mockito#when(Object)} is always recommended for stubbing because it is argument type-safe
     * and more readable&lt;/b&gt; (especially when stubbing consecutive calls).
     * &lt;p&gt;
     * Here are those rare occasions when doReturn() comes handy:
     * &lt;p&gt;
     *
     * &lt;ol&gt;
     * &lt;li&gt;When spying real objects and calling real methods on a spy brings side effects
     *
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   List list = new LinkedList();
     *   List spy = spy(list);
     *
     *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)
     *   when(spy.get(0)).thenReturn(&quot;foo&quot;);
     *
     *   //You have to use doReturn() for stubbing:
     *   doReturn(&quot;foo&quot;).when(spy).get(0);
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;/li&gt;
     *
     * &lt;li&gt;Overriding a previous exception-stubbing:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   when(mock.foo()).thenThrow(new RuntimeException());
     *
     *   //Impossible: the exception-stubbed foo() method is called so RuntimeException is thrown.
     *   when(mock.foo()).thenReturn(&quot;bar&quot;);
     *
     *   //You have to use doReturn() for stubbing:
     *   doReturn(&quot;bar&quot;).when(mock).foo();
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;/li&gt;
     * &lt;/ol&gt;
     *
     * Above scenarios shows a tradeoff of Mockito's elegant syntax. Note that the scenarios are very rare, though.
     * Spying should be sporadic and overriding exception-stubbing is very rare. Not to mention that in general
     * overridding stubbing is a potential code smell that points out too much stubbing.
     * &lt;p&gt;
     * See examples in javadoc for {@link Mockito} class
     *
     * @param toBeReturned to be returned when the stubbed method is called
     * @return stubber - to select a method for stubbing
     */
    @CheckReturnValue
    public static Stubber doReturn(Object toBeReturned) {
<span class="fc" id="L2473">        return MOCKITO_CORE.stubber().doReturn(toBeReturned);</span>
    }

    /**
     * Same as {@link #doReturn(Object)} but sets consecutive values to be returned. Remember to use
     * &lt;code&gt;doReturn()&lt;/code&gt; in those rare occasions when you cannot use {@link Mockito#when(Object)}.
     * &lt;p&gt;
     * &lt;b&gt;Beware that {@link Mockito#when(Object)} is always recommended for stubbing because it is argument type-safe
     * and more readable&lt;/b&gt; (especially when stubbing consecutive calls).
     * &lt;p&gt;
     * Here are those rare occasions when doReturn() comes handy:
     * &lt;p&gt;
     *
     * &lt;ol&gt;
     * &lt;li&gt;When spying real objects and calling real methods on a spy brings side effects
     *
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   List list = new LinkedList();
     *   List spy = spy(list);
     *
     *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)
     *   when(spy.get(0)).thenReturn(&quot;foo&quot;, &quot;bar&quot;, &quot;qix&quot;);
     *
     *   //You have to use doReturn() for stubbing:
     *   doReturn(&quot;foo&quot;, &quot;bar&quot;, &quot;qix&quot;).when(spy).get(0);
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;/li&gt;
     *
     * &lt;li&gt;Overriding a previous exception-stubbing:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   when(mock.foo()).thenThrow(new RuntimeException());
     *
     *   //Impossible: the exception-stubbed foo() method is called so RuntimeException is thrown.
     *   when(mock.foo()).thenReturn(&quot;bar&quot;, &quot;foo&quot;, &quot;qix&quot;);
     *
     *   //You have to use doReturn() for stubbing:
     *   doReturn(&quot;bar&quot;, &quot;foo&quot;, &quot;qix&quot;).when(mock).foo();
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;/li&gt;
     * &lt;/ol&gt;
     *
     * Above scenarios shows a trade-off of Mockito's elegant syntax. Note that the scenarios are very rare, though.
     * Spying should be sporadic and overriding exception-stubbing is very rare. Not to mention that in general
     * overridding stubbing is a potential code smell that points out too much stubbing.
     * &lt;p&gt;
     * See examples in javadoc for {@link Mockito} class
     *
     * @param toBeReturned to be returned when the stubbed method is called
     * @param toBeReturnedNext to be returned in consecutive calls when the stubbed method is called
     * @return stubber - to select a method for stubbing
     * @since 2.1.0
     */
    @SuppressWarnings({&quot;unchecked&quot;, &quot;varargs&quot;})
    @CheckReturnValue
    public static Stubber doReturn(Object toBeReturned, Object... toBeReturnedNext) {
<span class="fc" id="L2528">        return MOCKITO_CORE.stubber().doReturn(toBeReturned, toBeReturnedNext);</span>
    }

    /**
     * Creates {@link org.mockito.InOrder} object that allows verifying mocks in order.
     *
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   InOrder inOrder = inOrder(firstMock, secondMock);
     *
     *   inOrder.verify(firstMock).add(&quot;was called first&quot;);
     *   inOrder.verify(secondMock).add(&quot;was called second&quot;);
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * Verification in order is flexible - &lt;b&gt;you don't have to verify all interactions&lt;/b&gt; one-by-one
     * but only those that you are interested in testing in order.
     * &lt;p&gt;
     * Also, you can create InOrder object passing only mocks that are relevant for in-order verification.
     * &lt;p&gt;
     * &lt;code&gt;InOrder&lt;/code&gt; verification is 'greedy', but you will hardly ever notice it.
     * If you want to find out more, read
     * &lt;a href=&quot;https://github.com/mockito/mockito/wiki/Greedy-algorithm-of-verfication-InOrder&quot;&gt;this wiki page&lt;/a&gt;.
     * &lt;p&gt;
     * As of Mockito 1.8.4 you can verifyNoMoreInvocations() in order-sensitive way. Read more: {@link InOrder#verifyNoMoreInteractions()}
     * &lt;p&gt;
     * See examples in javadoc for {@link Mockito} class
     *
     * @param mocks to be verified in order
     *
     * @return InOrder object to be used to verify in order
     */
    @CheckReturnValue
    public static InOrder inOrder(Object... mocks) {
<span class="fc" id="L2560">        return MOCKITO_CORE.inOrder(mocks);</span>
    }

    /**
     * Ignores stubbed methods of given mocks for the sake of verification.
     * Please consider using {@link Strictness#STRICT_STUBS} feature which eliminates the need for &lt;code&gt;ignoreStubs()&lt;/code&gt;
     * and provides other benefits.
     * &lt;p&gt;
     * &lt;code&gt;ignoreStubs()&lt;/code&gt; is sometimes useful when coupled with &lt;code&gt;verifyNoMoreInteractions()&lt;/code&gt; or verification &lt;code&gt;inOrder()&lt;/code&gt;.
     * Helps avoiding redundant verification of stubbed calls - typically we're not interested in verifying stubs.
     * &lt;p&gt;
     * &lt;b&gt;Warning&lt;/b&gt;, &lt;code&gt;ignoreStubs()&lt;/code&gt; might lead to overuse of &lt;code&gt;verifyNoMoreInteractions(ignoreStubs(...));&lt;/code&gt;
     * Bear in mind that Mockito does not recommend bombarding every test with &lt;code&gt;verifyNoMoreInteractions()&lt;/code&gt;
     * for the reasons outlined in javadoc for {@link Mockito#verifyNoMoreInteractions(Object...)}
     * Other words: all &lt;b&gt;*stubbed*&lt;/b&gt; methods of given mocks are marked &lt;b&gt;*verified*&lt;/b&gt; so that they don't get in a way during verifyNoMoreInteractions().
     * &lt;p&gt;
     * This method &lt;b&gt;changes the input mocks&lt;/b&gt;! This method returns input mocks just for convenience.
     * &lt;p&gt;
     * Ignored stubs will also be ignored for verification inOrder, including {@link org.mockito.InOrder#verifyNoMoreInteractions()}.
     * See the second example.
     * &lt;p&gt;
     * Example:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *  //mocking lists for the sake of the example (if you mock List in real you will burn in hell)
     *  List mock1 = mock(List.class), mock2 = mock(List.class);
     *
     *  //stubbing mocks:
     *  when(mock1.get(0)).thenReturn(10);
     *  when(mock2.get(0)).thenReturn(20);
     *
     *  //using mocks by calling stubbed get(0) methods:
     *  System.out.println(mock1.get(0)); //prints 10
     *  System.out.println(mock2.get(0)); //prints 20
     *
     *  //using mocks by calling clear() methods:
     *  mock1.clear();
     *  mock2.clear();
     *
     *  //verification:
     *  verify(mock1).clear();
     *  verify(mock2).clear();
     *
     *  //verifyNoMoreInteractions() fails because get() methods were not accounted for.
     *  try { verifyNoMoreInteractions(mock1, mock2); } catch (NoInteractionsWanted e);
     *
     *  //However, if we ignore stubbed methods then we can verifyNoMoreInteractions()
     *  verifyNoMoreInteractions(ignoreStubs(mock1, mock2));
     *
     *  //Remember that ignoreStubs() &lt;b&gt;*changes*&lt;/b&gt; the input mocks and returns them for convenience.
     * &lt;/code&gt;&lt;/pre&gt;
     * Ignoring stubs can be used with &lt;b&gt;verification in order&lt;/b&gt;:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *  List list = mock(List.class);
     *  when(list.get(0)).thenReturn(&quot;foo&quot;);
     *
     *  list.add(0);
     *  list.clear();
     *  System.out.println(list.get(0)); //we don't want to verify this
     *
     *  InOrder inOrder = inOrder(ignoreStubs(list));
     *  inOrder.verify(list).add(0);
     *  inOrder.verify(list).clear();
     *  inOrder.verifyNoMoreInteractions();
     * &lt;/code&gt;&lt;/pre&gt;
     * Stubbed invocations are automatically verified with {@link Strictness#STRICT_STUBS} feature
     * and it eliminates the need for &lt;code&gt;ignoreStubs()&lt;/code&gt;. Example below uses JUnit Rules:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *  &amp;#064;Rule public MockitoRule mockito = MockitoJUnit.rule().strictness(Strictness.STRICT_STUBS);
     *
     *  List list = mock(List.class);
     *  when(list.get(0)).thenReturn(&quot;foo&quot;);
     *
     *  list.size();
     *  verify(list).size();
     *
     *  list.get(0); // Automatically verified by STRICT_STUBS
     *  verifyNoMoreInteractions(list); // No need of ignoreStubs()
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * @since 1.9.0
     * @param mocks input mocks that will be changed
     * @return the same mocks that were passed in as parameters
     */
    public static Object[] ignoreStubs(Object... mocks) {
<span class="fc" id="L2644">        return MOCKITO_CORE.ignoreStubs(mocks);</span>
    }

    /**
     * Allows verifying exact number of invocations. E.g:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   verify(mock, times(2)).someMethod(&quot;some arg&quot;);
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * See examples in javadoc for {@link Mockito} class
     *
     * @param wantedNumberOfInvocations wanted number of invocations
     *
     * @return verification mode
     */
    @CheckReturnValue
    public static VerificationMode times(int wantedNumberOfInvocations) {
<span class="fc" id="L2661">        return VerificationModeFactory.times(wantedNumberOfInvocations);</span>
    }

    /**
     * Alias to &lt;code&gt;times(0)&lt;/code&gt;, see {@link Mockito#times(int)}
     * &lt;p&gt;
     * Verifies that interaction did not happen. E.g:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   verify(mock, never()).someMethod();
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * &lt;p&gt;
     * If you want to verify there were NO interactions with the mock
     * check out {@link Mockito#verifyZeroInteractions(Object...)}
     * or {@link Mockito#verifyNoMoreInteractions(Object...)}
     * &lt;p&gt;
     * See examples in javadoc for {@link Mockito} class
     *
     * @return verification mode
     */
    @CheckReturnValue
    public static VerificationMode never() {
<span class="fc" id="L2683">        return times(0);</span>
    }

    /**
     * Allows at-least-once verification. E.g:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   verify(mock, atLeastOnce()).someMethod(&quot;some arg&quot;);
     * &lt;/code&gt;&lt;/pre&gt;
     * Alias to &lt;code&gt;atLeast(1)&lt;/code&gt;.
     * &lt;p&gt;
     * See examples in javadoc for {@link Mockito} class
     *
     * @return verification mode
     */
    @CheckReturnValue
    public static VerificationMode atLeastOnce() {
<span class="fc" id="L2699">        return VerificationModeFactory.atLeastOnce();</span>
    }

    /**
     * Allows at-least-x verification. E.g:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   verify(mock, atLeast(3)).someMethod(&quot;some arg&quot;);
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * See examples in javadoc for {@link Mockito} class
     *
     * @param minNumberOfInvocations minimum number of invocations
     *
     * @return verification mode
     */
    @CheckReturnValue
    public static VerificationMode atLeast(int minNumberOfInvocations) {
<span class="fc" id="L2716">        return VerificationModeFactory.atLeast(minNumberOfInvocations);</span>
    }

    /**
     * Allows at-most-x verification. E.g:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   verify(mock, atMost(3)).someMethod(&quot;some arg&quot;);
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * See examples in javadoc for {@link Mockito} class
     *
     * @param maxNumberOfInvocations max number of invocations
     *
     * @return verification mode
     */
    @CheckReturnValue
    public static VerificationMode atMost(int maxNumberOfInvocations) {
<span class="fc" id="L2733">        return VerificationModeFactory.atMost(maxNumberOfInvocations);</span>
    }

    /**
     * Allows non-greedy verification in order.  For example
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   inOrder.verify( mock, calls( 2 )).someMethod( &quot;some arg&quot; );
     * &lt;/code&gt;&lt;/pre&gt;
     * &lt;ul&gt;
     * &lt;li&gt;will not fail if the method is called 3 times, unlike times( 2 )&lt;/li&gt;
     * &lt;li&gt;will not mark the third invocation as verified, unlike atLeast( 2 )&lt;/li&gt;
     * &lt;/ul&gt;
     * This verification mode can only be used with in order verification.
     * @param wantedNumberOfInvocations number of invocations to verify
     * @return  verification mode
     */
    @CheckReturnValue
    public static VerificationMode calls( int wantedNumberOfInvocations ){
<span class="fc" id="L2751">        return VerificationModeFactory.calls( wantedNumberOfInvocations );</span>
    }

    /**
     * Allows checking if given method was the only one invoked. E.g:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   verify(mock, only()).someMethod();
     *   //above is a shorthand for following 2 lines of code:
     *   verify(mock).someMethod();
     *   verifyNoMoreInvocations(mock);
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * &lt;p&gt;
     * See also {@link Mockito#verifyNoMoreInteractions(Object...)}
     * &lt;p&gt;
     * See examples in javadoc for {@link Mockito} class
     *
     * @return verification mode
     */
    @CheckReturnValue
    public static VerificationMode only() {
<span class="fc" id="L2772">        return VerificationModeFactory.only();</span>
    }

    /**
     * Verification will be triggered after given amount of millis, allowing testing of async code.
     * Useful when interactions with the mock object did not happened yet.
     * Extensive use of after() method can be a code smell - there are better ways of testing concurrent code.
     * &lt;p&gt;
     * See also {@link #after(long)} method for testing async code.
     * Differences between {@code timeout()} and {@code after} are explained in Javadoc for {@link #after(long)}.
     * &lt;p&gt;
     * Extensive use of {@code timeout()} method can be a code smell - there are better ways of testing concurrent code.
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   //passes when someMethod() is called no later than within 100 ms
     *   //exits immediately when verification is satisfied (e.g. may not wait full 100 ms)
     *   verify(mock, timeout(100)).someMethod();
     *   //above is an alias to:
     *   verify(mock, timeout(100).times(1)).someMethod();
     *
     *   //passes as soon as someMethod() has been called 2 times under 100 ms
     *   verify(mock, timeout(100).times(2)).someMethod();
     *
     *   //equivalent: this also passes as soon as someMethod() has been called 2 times under 100 ms
     *   verify(mock, timeout(100).atLeast(2)).someMethod();
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * See examples in javadoc for {@link Mockito} class
     *
     * @param millis - duration in milliseconds
     *
     * @return object that allows fluent specification of the verification (times(x), atLeast(y), etc.)
     */
    @CheckReturnValue
    public static VerificationWithTimeout timeout(long millis) {
<span class="fc" id="L2806">        return new Timeout(millis, VerificationModeFactory.times(1));</span>
    }

    /**
     * Verification will be triggered after given amount of millis, allowing testing of async code.
     * Useful when interactions with the mock object did not happened yet.
     * Extensive use of after() method can be a code smell - there are better ways of testing concurrent code.
     * &lt;p&gt;
     * Not yet implemented to work with InOrder verification.
     * &lt;p&gt;
     * See also {@link #timeout(long)} method for testing async code.
     * Differences between {@code timeout()} and {@code after()} are explained below.
     *
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   //passes after 100ms, if someMethod() has only been called once at that time.
     *   verify(mock, after(100)).someMethod();
     *   //above is an alias to:
     *   verify(mock, after(100).times(1)).someMethod();
     *
     *   //passes if someMethod() is called &lt;b&gt;*exactly*&lt;/b&gt; 2 times, as tested after 100 millis
     *   verify(mock, after(100).times(2)).someMethod();
     *
     *   //passes if someMethod() has not been called, as tested after 100 millis
     *   verify(mock, after(100).never()).someMethod();
     *
     *   //verifies someMethod() after a given time span using given verification mode
     *   //useful only if you have your own custom verification modes.
     *   verify(mock, new After(100, yourOwnVerificationMode)).someMethod();
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * &lt;strong&gt;timeout() vs. after()&lt;/strong&gt;
     * &lt;ul&gt;
     *     &lt;li&gt;timeout() exits immediately with success when verification passes&lt;/li&gt;
     *     &lt;li&gt;after() awaits full duration to check if verification passes&lt;/li&gt;
     * &lt;/ul&gt;
     * Examples:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   //1.
     *   mock.foo();
     *   verify(mock, after(1000)).foo();
     *   //waits 1000 millis and succeeds
     *
     *   //2.
     *   mock.foo();
     *   verify(mock, timeout(1000)).foo();
     *   //succeeds immediately
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * See examples in javadoc for {@link Mockito} class
     *
     * @param millis - duration in milliseconds
     *
     * @return object that allows fluent specification of the verification
     */
    @CheckReturnValue
    public static VerificationAfterDelay after(long millis) {
<span class="fc" id="L2862">        return new After(millis, VerificationModeFactory.times(1));</span>
    }

    /**
     * First of all, in case of any trouble, I encourage you to read the Mockito FAQ: &lt;a href=&quot;https://github.com/mockito/mockito/wiki/FAQ&quot;&gt;https://github.com/mockito/mockito/wiki/FAQ&lt;/a&gt;
     * &lt;p&gt;
     * In case of questions you may also post to mockito mailing list: &lt;a href=&quot;http://groups.google.com/group/mockito&quot;&gt;http://groups.google.com/group/mockito&lt;/a&gt;
     * &lt;p&gt;
     * &lt;code&gt;validateMockitoUsage()&lt;/code&gt; &lt;b&gt;explicitly validates&lt;/b&gt; the framework state to detect invalid use of Mockito.
     * However, this feature is optional &lt;b&gt;because Mockito validates the usage all the time...&lt;/b&gt; but there is a gotcha so read on.
     * &lt;p&gt;
     * Examples of incorrect use:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     * //Oops, thenReturn() part is missing:
     * when(mock.get());
     *
     * //Oops, verified method call is inside verify() where it should be on the outside:
     * verify(mock.execute());
     *
     * //Oops, missing method to verify:
     * verify(mock);
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * Mockito throws exceptions if you misuse it so that you know if your tests are written correctly.
     * The gotcha is that Mockito does the validation &lt;b&gt;next time&lt;/b&gt; you use the framework (e.g. next time you verify, stub, call mock etc.).
     * But even though the exception might be thrown in the next test,
     * the exception &lt;b&gt;message contains a navigable stack trace element&lt;/b&gt; with location of the defect.
     * Hence you can click and find the place where Mockito was misused.
     * &lt;p&gt;
     * Sometimes though, you might want to validate the framework usage explicitly.
     * For example, one of the users wanted to put &lt;code&gt;validateMockitoUsage()&lt;/code&gt; in his &lt;code&gt;&amp;#064;After&lt;/code&gt; method
     * so that he knows immediately when he misused Mockito.
     * Without it, he would have known about it not sooner than &lt;b&gt;next time&lt;/b&gt; he used the framework.
     * One more benefit of having &lt;code&gt;validateMockitoUsage()&lt;/code&gt; in &lt;code&gt;&amp;#064;After&lt;/code&gt; is that jUnit runner and rule will always fail in the test method with defect
     * whereas ordinary 'next-time' validation might fail the &lt;b&gt;next&lt;/b&gt; test method.
     * But even though JUnit might report next test as red, don't worry about it
     * and just click at navigable stack trace element in the exception message to instantly locate the place where you misused mockito.
     * &lt;p&gt;
     * &lt;b&gt;Both built-in runner: {@link MockitoJUnitRunner} and rule: {@link MockitoRule}&lt;/b&gt; do validateMockitoUsage() after each test method.
     * &lt;p&gt;
     * Bear in mind that &lt;b&gt;usually you don't have to &lt;code&gt;validateMockitoUsage()&lt;/code&gt;&lt;/b&gt;
     * and framework validation triggered on next-time basis should be just enough,
     * mainly because of enhanced exception message with clickable location of defect.
     * However, I would recommend validateMockitoUsage() if you already have sufficient test infrastructure
     * (like your own runner or base class for all tests) because adding a special action to &lt;code&gt;&amp;#064;After&lt;/code&gt; has zero cost.
     * &lt;p&gt;
     * See examples in javadoc for {@link Mockito} class
     */
    public static void validateMockitoUsage() {
<span class="fc" id="L2911">        MOCKITO_CORE.validateMockitoUsage();</span>
<span class="fc" id="L2912">    }</span>

    /**
     * Allows mock creation with additional mock settings.
     * &lt;p&gt;
     * Don't use it too often.
     * Consider writing simple tests that use simple mocks.
     * Repeat after me: simple tests push simple, KISSy, readable &amp; maintainable code.
     * If you cannot write a test in a simple way - refactor the code under test.
     * &lt;p&gt;
     * Examples of mock settings:
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   //Creates mock with different default answer &amp; name
     *   Foo mock = mock(Foo.class, withSettings()
     *       .defaultAnswer(RETURNS_SMART_NULLS)
     *       .name(&quot;cool mockie&quot;));
     *
     *   //Creates mock with different default answer, descriptive name and extra interfaces
     *   Foo mock = mock(Foo.class, withSettings()
     *       .defaultAnswer(RETURNS_SMART_NULLS)
     *       .name(&quot;cool mockie&quot;)
     *       .extraInterfaces(Bar.class));
     * &lt;/code&gt;&lt;/pre&gt;
     * {@link MockSettings} has been introduced for two reasons.
     * Firstly, to make it easy to add another mock settings when the demand comes.
     * Secondly, to enable combining different mock settings without introducing zillions of overloaded mock() methods.
     * &lt;p&gt;
     * See javadoc for {@link MockSettings} to learn about possible mock settings.
     * &lt;p&gt;
     *
     * @return mock settings instance with defaults.
     */
    @CheckReturnValue
    public static MockSettings withSettings() {
<span class="fc" id="L2946">        return new MockSettingsImpl().defaultAnswer(RETURNS_DEFAULTS);</span>
    }

    /**
     * Adds a description to be printed if verification fails.
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     * verify(mock, description(&quot;This will print on failure&quot;)).someMethod(&quot;some arg&quot;);
     * &lt;/code&gt;&lt;/pre&gt;
     * @param description The description to print on failure.
     * @return verification mode
     * @since 2.1.0
     */
    @CheckReturnValue
    public static VerificationMode description(String description) {
<span class="fc" id="L2960">        return times(1).description(description);</span>
    }

    /**
     * @deprecated - please use {@link MockingDetails#printInvocations()} instead.
     * An instance of {@code MockingDetails} can be retrieved via {@link #mockingDetails(Object)}.
     */
    @Deprecated
    @CheckReturnValue
    static MockitoDebugger debug() {
<span class="nc" id="L2970">        return new MockitoDebuggerImpl();</span>
    }

    /**
     * For advanced users or framework integrators. See {@link MockitoFramework} class.
     *
     * @since 2.1.0
     */
    @Incubating
    @CheckReturnValue
    public static MockitoFramework framework() {
<span class="fc" id="L2981">        return new DefaultMockitoFramework();</span>
    }

    /**
     * {@code MockitoSession} is an optional, highly recommended feature
     * that helps driving cleaner tests by eliminating boilerplate code and adding extra validation.
     * &lt;p&gt;
     * For more information, including use cases and sample code, see the javadoc for {@link MockitoSession}.
     *
     * @since 2.7.0
     */
    @Incubating
    @CheckReturnValue
    public static MockitoSessionBuilder mockitoSession() {
<span class="fc" id="L2995">        return new DefaultMockitoSessionBuilder();</span>
    }

    /**
     * Lenient stubs bypass &quot;strict stubbing&quot; validation (see {@link Strictness#STRICT_STUBS}).
     * When stubbing is declared as lenient, it will not be checked for potential stubbing problems such as
     * 'unnecessary stubbing' ({@link UnnecessaryStubbingException}) or for 'stubbing argument mismatch' {@link PotentialStubbingProblem}.
     *
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *   lenient().when(mock.foo()).thenReturn(&quot;ok&quot;);
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * Most mocks in most tests don't need leniency and should happily prosper with {@link Strictness#STRICT_STUBS}.
     * &lt;ul&gt;
     *     &lt;li&gt;If a specific stubbing needs to be lenient - use this method&lt;/li&gt;
     *     &lt;li&gt;If a specific mock need to have stubbings lenient - use {@link MockSettings#lenient()}&lt;/li&gt;
     *     &lt;li&gt;If a specific test method / test class needs to have all stubbings lenient
     *          - configure strictness using our JUnit support ({@link MockitoJUnit} or Mockito Session ({@link MockitoSession})&lt;/li&gt;
     *
     * &lt;h3&gt;Elaborate example&lt;/h3&gt;
     *
     * In below example, 'foo.foo()' is a stubbing that was moved to 'before()' method to avoid duplication.
     * Doing so makes one of the test methods ('test3()') fail with 'unnecessary stubbing'.
     * To resolve it we can configure 'foo.foo()' stubbing in 'before()' method to be lenient.
     * Alternatively, we can configure entire 'foo' mock as lenient.
     * &lt;p&gt;
     * This example is simplified and not realistic.
     * Pushing stubbings to 'before()' method may cause tests to be less readable.
     * Some repetition in tests is OK, use your own judgement to write great tests!
     * It is not desired to eliminate all possible duplication from the test code
     * because it may add complexity and conceal important test information.
     *
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     * public class SomeTest {
     *
     *     &amp;#064;Rule public MockitoRule mockito = MockitoJUnit.rule().strictness(STRICT_STUBS);
     *
     *     &amp;#064;Mock Foo foo;
     *     &amp;#064;Mock Bar bar;
     *
     *     &amp;#064;Before public void before() {
     *         when(foo.foo()).thenReturn(&quot;ok&quot;);
     *
     *         // it is better to configure the stubbing to be lenient:
     *         // lenient().when(foo.foo()).thenReturn(&quot;ok&quot;);
     *
     *         // or the entire mock to be lenient:
     *         // foo = mock(Foo.class, withSettings().lenient());
     *     }
     *
     *     &amp;#064;Test public void test1() {
     *         foo.foo();
     *     }
     *
     *     &amp;#064;Test public void test2() {
     *         foo.foo();
     *     }
     *
     *     &amp;#064;Test public void test3() {
     *         bar.bar();
     *     }
     * }
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * @since 2.20.0
     */
    @Incubating
    public static LenientStubber lenient() {
<span class="fc" id="L3063">        return MOCKITO_CORE.lenient();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>