<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="sv"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ReturnsSmartNulls.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mockito</a> &gt; <a href="index.source.html" class="el_package">org.mockito.internal.stubbing.defaultanswers</a> &gt; <span class="el_source">ReturnsSmartNulls.java</span></div><h1>ReturnsSmartNulls.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2007 Mockito contributors
 * This program is made available under the terms of the MIT License.
 */
package org.mockito.internal.stubbing.defaultanswers;

import static org.mockito.internal.exceptions.Reporter.smartNullPointerException;
import static org.mockito.internal.util.ObjectMethodsGuru.isToStringMethod;

import java.io.Serializable;
import java.lang.reflect.GenericArrayType;
import java.lang.reflect.Modifier;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;

import org.mockito.Mockito;
import org.mockito.internal.debugging.LocationImpl;
import org.mockito.internal.util.MockUtil;
import org.mockito.internal.util.reflection.GenericMetadataSupport;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.invocation.Location;
import org.mockito.mock.MockCreationSettings;
import org.mockito.stubbing.Answer;

/**
 * Optional Answer that can be used with
 * {@link Mockito#mock(Class, Answer)}
 * &lt;p&gt;
 * This implementation can be helpful when working with legacy code. Unstubbed
 * methods often return null. If your code uses the object returned by an
 * unstubbed call you get a NullPointerException. This implementation of
 * Answer returns SmartNulls instead of nulls.
 * SmartNull gives nicer exception message than NPE because it points out the
 * line where unstubbed method was called. You just click on the stack trace.
 * &lt;p&gt;
 * ReturnsSmartNulls first tries to return ordinary return values (see
 * {@link ReturnsMoreEmptyValues}) then it tries to return SmartNull. If the
 * return type is not mockable (e.g. final) then ordinary null is returned.
 * &lt;p&gt;
 * ReturnsSmartNulls will be probably the default return values strategy in
 * Mockito 2.1.0
 */
<span class="fc" id="L43">public class ReturnsSmartNulls implements Answer&lt;Object&gt;, Serializable {</span>

    private static final long serialVersionUID = 7618312406617949441L;

<span class="fc" id="L47">    private final Answer&lt;Object&gt; delegate = new ReturnsMoreEmptyValues();</span>

    public Object answer(final InvocationOnMock invocation) throws Throwable {
<span class="fc" id="L50">        Object defaultReturnValue = delegate.answer(invocation);</span>
<span class="fc bfc" id="L51" title="All 2 branches covered.">        if (defaultReturnValue != null) {</span>
<span class="fc" id="L52">            return defaultReturnValue;</span>
        }
<span class="fc" id="L54">        Class&lt;?&gt; type = invocation.getMethod().getReturnType();</span>

<span class="fc" id="L56">        final Type returnType = invocation.getMethod().getGenericReturnType();</span>
<span class="fc bfc" id="L57" title="All 2 branches covered.">        if (returnType instanceof TypeVariable) {</span>
<span class="fc" id="L58">            type = findTypeFromGeneric(invocation, (TypeVariable) returnType);</span>
<span class="fc bfc" id="L59" title="All 2 branches covered.">            if (type != null) {</span>
<span class="fc" id="L60">                defaultReturnValue = delegateChains(type);</span>
            }
        }
<span class="fc bfc" id="L63" title="All 2 branches covered.">        if (defaultReturnValue != null) {</span>
<span class="fc" id="L64">            return defaultReturnValue;</span>
        }

<span class="pc bpc" id="L67" title="2 of 6 branches missed.">        if (type != null &amp;&amp; !type.isPrimitive() &amp;&amp; !Modifier.isFinal(type.getModifiers())) {</span>
<span class="fc" id="L68">            final Location location = new LocationImpl();</span>
<span class="fc" id="L69">            return Mockito.mock(type, new ThrowsSmartNullPointer(invocation, location));</span>
        }
<span class="fc" id="L71">        return null;</span>
    }

    /**
     * Try to resolve the result value using {@link ReturnsEmptyValues} and {@link ReturnsMoreEmptyValues}.
     *
     * This will try to use all parent class (superclass &amp; interfaces) to retrieve the value..
     *
     * @param type the return type of the method
     * @return a non-null instance if the type has been resolve. Null otherwise.
     */
    private Object delegateChains(final Class&lt;?&gt; type) {
<span class="fc" id="L83">        final ReturnsEmptyValues returnsEmptyValues = new ReturnsEmptyValues();</span>
<span class="fc" id="L84">        Object result = returnsEmptyValues.returnValueFor(type);</span>

<span class="fc bfc" id="L86" title="All 2 branches covered.">        if (result == null) {</span>
<span class="fc" id="L87">            Class&lt;?&gt; emptyValueForClass = type;</span>
<span class="fc bfc" id="L88" title="All 4 branches covered.">            while (emptyValueForClass != null &amp;&amp; result == null) {</span>
<span class="fc" id="L89">                final Class&lt;?&gt;[] classes = emptyValueForClass.getInterfaces();</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">                for (Class&lt;?&gt; clazz : classes) {</span>
<span class="fc" id="L91">                    result = returnsEmptyValues.returnValueFor(clazz);</span>
<span class="fc bfc" id="L92" title="All 2 branches covered.">                    if (result != null) {</span>
<span class="fc" id="L93">                        break;</span>
                    }
                }
<span class="fc" id="L96">                emptyValueForClass = emptyValueForClass.getSuperclass();</span>
<span class="fc" id="L97">            }</span>
        }

<span class="fc bfc" id="L100" title="All 2 branches covered.">        if (result == null) {</span>
<span class="fc" id="L101">            result = new ReturnsMoreEmptyValues().returnValueFor(type);</span>
        }

<span class="fc" id="L104">        return result;</span>
    }

    /**
     * Retrieve the expected type when it came from a primitive. If the type cannot be retrieve, return null.
     *
     * @param invocation the current invocation
     * @param returnType the expected return type
     * @return the type or null if not found
     */
    private Class&lt;?&gt; findTypeFromGeneric(final InvocationOnMock invocation, final TypeVariable returnType) {
        // Class level
<span class="fc" id="L116">        final MockCreationSettings mockSettings = MockUtil.getMockHandler(invocation.getMock()).getMockSettings();</span>
<span class="fc" id="L117">        final GenericMetadataSupport returnTypeSupport = GenericMetadataSupport</span>
<span class="fc" id="L118">            .inferFrom(mockSettings.getTypeToMock())</span>
<span class="fc" id="L119">            .resolveGenericReturnType(invocation.getMethod());</span>
<span class="fc" id="L120">        final Class&lt;?&gt; rawType = returnTypeSupport.rawType();</span>

        // Method level
<span class="fc bfc" id="L123" title="All 2 branches covered.">        if (rawType == Object.class) {</span>
<span class="fc" id="L124">            return findTypeFromGenericInArguments(invocation, returnType);</span>
        }
<span class="fc" id="L126">        return rawType;</span>
    }

    /**
     * Find a return type using generic arguments provided by the calling method.
     *
     * @param invocation the current invocation
     * @param returnType the expected return type
     * @return the return type or null if the return type cannot be found
     */
    private Class&lt;?&gt; findTypeFromGenericInArguments(final InvocationOnMock invocation, final TypeVariable returnType) {
<span class="fc" id="L137">        final Type[] parameterTypes = invocation.getMethod().getGenericParameterTypes();</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">        for (int i = 0; i &lt; parameterTypes.length; i++) {</span>
<span class="fc" id="L139">            Type argType = parameterTypes[i];</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">            if (returnType.equals(argType)) {</span>
<span class="fc" id="L141">                return invocation.getArgument(i).getClass();</span>
            }
<span class="fc bfc" id="L143" title="All 2 branches covered.">            if (argType instanceof GenericArrayType) {</span>
<span class="fc" id="L144">                argType = ((GenericArrayType) argType).getGenericComponentType();</span>
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">                if (returnType.equals(argType)) {</span>
<span class="fc" id="L146">                    return invocation.getArgument(i).getClass();</span>
                }
            }
        }
<span class="fc" id="L150">        return null;</span>
    }

    private static class ThrowsSmartNullPointer implements Answer {

        private final InvocationOnMock unstubbedInvocation;

        private final Location location;

<span class="fc" id="L159">        public ThrowsSmartNullPointer(InvocationOnMock unstubbedInvocation, Location location) {</span>
<span class="fc" id="L160">            this.unstubbedInvocation = unstubbedInvocation;</span>
<span class="fc" id="L161">            this.location = location;</span>
<span class="fc" id="L162">        }</span>

        public Object answer(InvocationOnMock currentInvocation) throws Throwable {
<span class="fc bfc" id="L165" title="All 2 branches covered.">            if (isToStringMethod(currentInvocation.getMethod())) {</span>
<span class="fc" id="L166">                return &quot;SmartNull returned by this unstubbed method call on a mock:\n&quot; +</span>
<span class="fc" id="L167">                    unstubbedInvocation.toString();</span>
            }

<span class="fc" id="L170">            throw smartNullPointerException(unstubbedInvocation.toString(), location);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>