<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="sv"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SpyAnnotationEngine.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mockito</a> &gt; <a href="index.source.html" class="el_package">org.mockito.internal.configuration</a> &gt; <span class="el_source">SpyAnnotationEngine.java</span></div><h1>SpyAnnotationEngine.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2007 Mockito contributors
 * This program is made available under the terms of the MIT License.
 */
package org.mockito.internal.configuration;

import java.lang.annotation.Annotation;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import org.mockito.Captor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockSettings;
import org.mockito.Mockito;
import org.mockito.Spy;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.internal.util.MockUtil;
import org.mockito.plugins.AnnotationEngine;

import static org.mockito.Mockito.CALLS_REAL_METHODS;
import static org.mockito.Mockito.withSettings;
import static org.mockito.internal.exceptions.Reporter.unsupportedCombinationOfAnnotations;
import static org.mockito.internal.util.StringUtil.join;

/**
 * Process fields annotated with &amp;#64;Spy.
 * &lt;p/&gt;
 * &lt;p&gt;
 * Will try transform the field in a spy as with &lt;code&gt;Mockito.spy()&lt;/code&gt;.
 * &lt;/p&gt;
 * &lt;p/&gt;
 * &lt;p&gt;
 * If the field is not initialized, will try to initialize it, with a no-arg constructor.
 * &lt;/p&gt;
 * &lt;p/&gt;
 * &lt;p&gt;
 * If the field is also annotated with the &lt;strong&gt;compatible&lt;/strong&gt; &amp;#64;InjectMocks then the field will be ignored,
 * The injection engine will handle this specific case.
 * &lt;/p&gt;
 * &lt;p/&gt;
 * &lt;p&gt;This engine will fail, if the field is also annotated with incompatible Mockito annotations.
 */
@SuppressWarnings({&quot;unchecked&quot;})
<span class="fc" id="L46">public class SpyAnnotationEngine implements AnnotationEngine, org.mockito.configuration.AnnotationEngine {</span>

    @Override
    public void process(Class&lt;?&gt; context, Object testInstance) {
<span class="fc" id="L50">        Field[] fields = context.getDeclaredFields();</span>
<span class="fc bfc" id="L51" title="All 2 branches covered.">        for (Field field : fields) {</span>
<span class="fc bfc" id="L52" title="All 4 branches covered.">            if (field.isAnnotationPresent(Spy.class) &amp;&amp; !field.isAnnotationPresent(InjectMocks.class)) {</span>
<span class="fc" id="L53">                assertNoIncompatibleAnnotations(Spy.class, field, Mock.class, Captor.class);</span>
<span class="fc" id="L54">                field.setAccessible(true);</span>
                Object instance;
                try {
<span class="fc" id="L57">                    instance = field.get(testInstance);</span>
<span class="fc bfc" id="L58" title="All 2 branches covered.">                    if (MockUtil.isMock(instance)) {</span>
                        // instance has been spied earlier
                        // for example happens when MockitoAnnotations.initMocks is called two times.
<span class="fc" id="L61">                        Mockito.reset(instance);</span>
<span class="fc bfc" id="L62" title="All 2 branches covered.">                    } else if (instance != null) {</span>
<span class="fc" id="L63">                        field.set(testInstance, spyInstance(field, instance));</span>
                    } else {
<span class="fc" id="L65">                        field.set(testInstance, spyNewInstance(testInstance, field));</span>
                    }
<span class="fc" id="L67">                } catch (Exception e) {</span>
<span class="fc" id="L68">                    throw new MockitoException(&quot;Unable to initialize @Spy annotated field '&quot; + field.getName() + &quot;'.\n&quot; + e.getMessage(), e);</span>
<span class="fc" id="L69">                }</span>
            }
        }
<span class="fc" id="L72">    }</span>

    private static Object spyInstance(Field field, Object instance) {
<span class="fc" id="L75">        return Mockito.mock(instance.getClass(),</span>
<span class="fc" id="L76">                            withSettings().spiedInstance(instance)</span>
<span class="fc" id="L77">                                                           .defaultAnswer(CALLS_REAL_METHODS)</span>
<span class="fc" id="L78">                                                           .name(field.getName()));</span>
    }

    private static Object spyNewInstance(Object testInstance, Field field)
            throws InstantiationException, IllegalAccessException, InvocationTargetException {
<span class="fc" id="L83">        MockSettings settings = withSettings().defaultAnswer(CALLS_REAL_METHODS)</span>
<span class="fc" id="L84">                                              .name(field.getName());</span>
<span class="fc" id="L85">        Class&lt;?&gt; type = field.getType();</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">        if (type.isInterface()) {</span>
<span class="fc" id="L87">            return Mockito.mock(type, settings.useConstructor());</span>
        }
<span class="fc" id="L89">        int modifiers = type.getModifiers();</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">        if (typeIsPrivateAbstractInnerClass(type, modifiers)) {</span>
<span class="fc" id="L91">            throw new MockitoException(join(&quot;@Spy annotation can't initialize private abstract inner classes.&quot;,</span>
<span class="fc" id="L92">                                            &quot;  inner class: '&quot; + type.getSimpleName() + &quot;'&quot;,</span>
<span class="fc" id="L93">                                            &quot;  outer class: '&quot; + type.getEnclosingClass().getSimpleName() + &quot;'&quot;,</span>
                                            &quot;&quot;,
                                            &quot;You should augment the visibility of this inner class&quot;));
        }
<span class="fc bfc" id="L97" title="All 2 branches covered.">        if (typeIsNonStaticInnerClass(type, modifiers)) {</span>
<span class="fc" id="L98">            Class&lt;?&gt; enclosing = type.getEnclosingClass();</span>
<span class="fc bfc" id="L99" title="All 2 branches covered.">            if (!enclosing.isInstance(testInstance)) {</span>
<span class="fc" id="L100">                throw new MockitoException(join(&quot;@Spy annotation can only initialize inner classes declared in the test.&quot;,</span>
<span class="fc" id="L101">                                                &quot;  inner class: '&quot; + type.getSimpleName() + &quot;'&quot;,</span>
<span class="fc" id="L102">                                                &quot;  outer class: '&quot; + enclosing.getSimpleName() + &quot;'&quot;,</span>
                                                &quot;&quot;));
            }
<span class="fc" id="L105">            return Mockito.mock(type, settings.useConstructor()</span>
<span class="fc" id="L106">                                              .outerInstance(testInstance));</span>
        }

<span class="fc" id="L109">        Constructor&lt;?&gt; constructor = noArgConstructorOf(type);</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">        if (Modifier.isPrivate(constructor.getModifiers())) {</span>
<span class="fc" id="L111">            constructor.setAccessible(true);</span>
<span class="fc" id="L112">            return Mockito.mock(type, settings.spiedInstance(constructor.newInstance()));</span>
        } else {
<span class="fc" id="L114">            return Mockito.mock(type, settings.useConstructor());</span>
        }
    }

    private static Constructor&lt;?&gt; noArgConstructorOf(Class&lt;?&gt; type) {
        Constructor&lt;?&gt; constructor;
        try {
<span class="fc" id="L121">            constructor = type.getDeclaredConstructor();</span>
<span class="fc" id="L122">        } catch (NoSuchMethodException e) {</span>
<span class="fc" id="L123">            throw new MockitoException(&quot;Please ensure that the type '&quot; + type.getSimpleName() + &quot;' has a no-arg constructor.&quot;);</span>
<span class="fc" id="L124">        }</span>
<span class="fc" id="L125">        return constructor;</span>
    }

    private static boolean typeIsNonStaticInnerClass(Class&lt;?&gt; type, int modifiers) {
<span class="fc bfc" id="L129" title="All 4 branches covered.">        return !Modifier.isStatic(modifiers) &amp;&amp; type.getEnclosingClass() != null;</span>
    }

    private static boolean typeIsPrivateAbstractInnerClass(Class&lt;?&gt; type, int modifiers) {
<span class="pc bpc" id="L133" title="1 of 6 branches missed.">        return Modifier.isPrivate(modifiers) &amp;&amp; Modifier.isAbstract(modifiers) &amp;&amp; type.getEnclosingClass() != null;</span>
    }

    //TODO duplicated elsewhere
    private static void assertNoIncompatibleAnnotations(Class&lt;? extends Annotation&gt; annotation,
                                                        Field field,
                                                        Class&lt;? extends Annotation&gt;... undesiredAnnotations) {
<span class="fc bfc" id="L140" title="All 2 branches covered.">        for (Class&lt;? extends Annotation&gt; u : undesiredAnnotations) {</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">            if (field.isAnnotationPresent(u)) {</span>
<span class="fc" id="L142">                throw unsupportedCombinationOfAnnotations(annotation.getSimpleName(),</span>
<span class="fc" id="L143">                                                          u.getSimpleName());</span>
            }
        }
<span class="fc" id="L146">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>